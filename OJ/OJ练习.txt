Lesson 1 栈和队列
1、https://leetcode-cn.com/problems/valid-parentheses/  [括号匹配问题]

typedef char ElemType;
typedef struct LinkStackNode
{
	ElemType data;
	struct LinkStackNode *link;
}LinkStackNode;

typedef LinkStackNode* LinkStack;
void LinkStackInit(LinkStack *pst);
void LinkStackPush(LinkStack *pst, ElemType x);
void LinkStackPop(LinkStack *pst);
ElemType LinkStackTop(LinkStack *pst);
int LinkStackSize(LinkStack *pst);
bool LinkStackEmpty(LinkStack *pst);
void LinkStackDestroy(LinkStack *pst);
/////////////////////////////////////////////////////

void LinkStackInit(LinkStack *pst)
{
	assert(pst != NULL);
	*pst = NULL;
}

void LinkStackPush(LinkStack *pst, ElemType x)
{
	assert(pst != NULL);
	LinkStackNode *node = (LinkStackNode*)malloc(sizeof(LinkStackNode));
	assert(node != NULL);
	node->data = x;

	node->link = *pst;
	*pst = node;
}
void LinkStackPop(LinkStack *pst)
{
	assert(pst != NULL);
	if(*pst != NULL)
	{
		LinkStackNode *p = *pst;
		*pst = p->link;
		free(p);
	}
}
ElemType LinkStackTop(LinkStack *pst)
{
	assert(pst != NULL && *pst != NULL);
	return (*pst)->data;
}

int LinkStackSize(LinkStack *pst)
{
	assert(pst != NULL);
	int size = 0;
	LinkStackNode *p = *pst;
	while(p != NULL)
	{
		size++;
		p = p->link;
	}
	return size;
}

bool LinkStackEmpty(LinkStack *pst)
{
    assert(pst != NULL);
    return *pst == NULL;
}

void LinkStackDestroy(LinkStack *pst)
{
	assert(pst != NULL);
	LinkStackNode *p = *pst;
	while(p != NULL)
	{
		*pst = p->link;
		free(p);
		p = *pst;
	}
}
//////////////////////////////////////////////////////////////

bool isValid(char * s)
{
    if(s == NULL)
        return false;
    if(*s == '\0')
        return true;

    LinkStack st;
    LinkStackInit(&st);

    while(*s != '\0')
    {
        if(*s=='{' || *s=='[' || *s=='(')
            LinkStackPush(&st, *s);
        else
        {
            if(LinkStackEmpty(&st))
				return false;
            char top = LinkStackTop(&st);
            if((*s=='}'&&top!='{') || (*s==']'&&top!='[') || (*s==')'&&top!='('))
                return false;
            LinkStackPop(&st);
        }
        s++;
    }
    bool flag = LinkStackEmpty(&st);
    LinkStackDestroy(&st);
    return flag;
}
2.https://www.nowcoder.com/practice/fc533c45b73a41b0b44ccba763f866ef?tpId=13&&tqId=11209&rp=1&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking
[删除重复的节点]
/*
struct ListNode {
    int val;
    struct ListNode *next;
    ListNode(int x) :
        val(x), next(NULL) {
    }
};
*/
class Solution {
public:
    ListNode* deleteDuplication(ListNode* pHead)
    {
        if(pHead==NULL)
            return pHead;
        ListNode *pre=NULL;
        ListNode *p=pHead;
        ListNode *next_node=p->next;
        
        while(next_node!=NULL)
        {
            if(next_node->val!=p->val)
            {
                pre=p;
                p=next_node;
                next_node=p->next;
            }
            else
            {
                while(next_node!=NULL&&next_node->val==p->val)
                    next_node=next_node->next;
                if(pre==NULL)
                    pHead=next_node;
                else
                    pre->next=next_node;
                while(p!=next_node)
                {
                    ListNode* tmp=p;
                    p=p->next;
                    free(tmp);
                }
                if(next_node!=NULL)
                    next_node=p->next;
            }
        }
        return pHead;
    }
};
Lesson 3 顺序表和链表
1、https://leetcode-cn.com/problems/remove-linked-list-elements/description/ [删除链表中等于给定值 val 的所有节点]
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* removeElements(struct ListNode* head, int val)
{
    if(head == NULL)
        return NULL;
    struct ListNode *p = head;
    struct ListNode *prev = NULL;
    while(p != NULL)
    {
        if(p->val == val)
        {
            struct ListNode *next = p->next;
            if(prev == NULL)
                head = head->next;
            else
                prev->next = p->next;
            free(p);
            p = next;
        }
        else
        {
            prev = p;
            p = p->next;
        }
    }
    return head;
}

2、https://leetcode-cn.com/problems/reverse-linked-list/description/  [反转一个单链表]
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */


struct ListNode* reverseList(struct ListNode* head)
{
    if(head==NULL || head->next==NULL)
        return head;
    struct ListNode *p = head;
    struct ListNode *q = p->next;
    p->next = NULL;
    while(q != NULL)
    {
        p = q;
        q = q->next;
        p->next = head;
        head = p;
    }
    return head;
}

3、https://leetcode-cn.com/problems/middle-of-the-linked-list/description/  [链表的中间结点]
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     struct ListNode *next;
 * };
 */

struct ListNode* middleNode(struct ListNode* head)
{
    if(head == NULL)
        return NULL;
    struct ListNode *fast, *slow;
    fast = slow = head;
    while(fast && fast->next!=NULL)
    {
        fast = fast->next->next;
        slow = slow->next;
    }
    return slow;
}

/*
struct ListNode* middleNode(struct ListNode* head)
{
    int len = 0;
    struct ListNode *p = head;
    while(p != NULL)
    {
        len++;
        p = p->next;
    }
    p = head;
    len /= 2;
    while(len-- > 0)
        p = p->next;
    return p;
}
*/

4、https://www.nowcoder.com/practice/529d3ae5a407492994ad2a246518148a?tpId=13&&tqId=11167&rp=2&ru=/activity/oj&qru=/ta/coding-interviews/question-ranking [输出该链表中倒数第k个结点]
/*
struct ListNode {
	int val;
	struct ListNode *next;
	ListNode(int x) :
			val(x), next(NULL) {
	}
};*/
class Solution {
public:
    ListNode* FindKthToTail(ListNode* pListHead, unsigned int k) 
    {
        if(pListHead == NULL)
            return NULL;
        ListNode *fast, *slow;
        fast = slow = pListHead;
        while(k-- > 0)
        {
            if(fast == NULL)
                return NULL;
            fast = fast->next;
        }
        
        while(fast != NULL)
        {
            fast = fast->next;
            slow = slow->next;
        }
        return slow;
    }
};
