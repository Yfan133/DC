/*
关联式容器：K模型 和 K-V模型
	底层为红黑树模型：
	map(key-v)  multimap(key-v,key可以重复)
	set(key)    multiset(key可重复)
	共同点：
		1.都是STL提供的关联式容器
		2.底层结构：红黑树
		3.红黑树：二叉平衡树 和 二叉搜索树的结合
			1.查找、插入、删除---》时间复杂度O(logn)
			2.中序遍历可以得到有序的结果
	不同点：主要是存储元素的类型不同

map：
模板：
	template<>
构造：map<type1, type2> board;
	map构造之后，内部是根据key来进行排序的
插入：
	m.insert(make_pair("apple", "苹果"));
	底层：insert:<iterator, bool>
	返回值：first:iterator，second:bool
重载[]：
	m["apple"] = "苹果"
	m["apple"]-->"苹果"
底层实现：
T& operator[](const K& x)
{
	return (*((this->insert(make_pair(x, T()))).first))
}
1.若key的节点不存在，则调用insert创建一个，并返回true和新创建的迭代器，然后重载的[]再返回second的引用
  若存在，则插入失败返回已存在的key的迭代器和false，重载[]再返回second的引用
2.返回值是引用类型，因此可以直接赋值

set：
作用：去重和排序

底层结构：
AVL树：
	1.二叉搜索树
	3.平衡因子的绝对值不超过1
		平衡因子：每个节点的左右子树之差
	因此AVL树又称：平衡二叉搜索树：查找的时间复杂度O(logN)
AVL插入规则：
	1.按二叉搜索树的规则进行插入
	2.循环判断平衡因子是否被破坏？
		1.没有被破坏：当平衡因子为0则跳出
		2.如果被破坏：旋转
		右单旋：(画个图)
			插入的位置：较高左子树的左侧
			方法：将根节点的左子树的节点向上提
				1.将根的左指向60，60的父指向根
				2.将50的右指向根
				3.原根的可能是子树，50的父指向pp，根的父指向50
				4.修改pp的左/右子树，判断根是pp的左还是右
				5.修改新根和根的右子树的平衡因子为0
		左单旋：
			插入位置：较高右子树的右侧
			方法：
		
		左右双旋：
			插入位置：较高左子树的右侧(直接右单旋之后还是不平衡的)
			方法：将subLR进行两次上提，先对subL左单旋，再对parent右单旋
				1.
				2.
				3.
		右左双旋：
			插入位置：
			方法：








*/