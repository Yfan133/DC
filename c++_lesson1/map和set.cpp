/*
关联式容器：K模型 和 K-V模型
	底层为红黑树模型：
	map(key-v)  multimap(key-v,key可以重复)
	set(key)    multiset(key可重复)
	共同点：
		1.都是STL提供的关联式容器
		2.底层结构：红黑树
		3.红黑树：二叉平衡树 和 二叉搜索树的结合
			1.查找、插入、删除---》时间复杂度O(logn)
			2.中序遍历可以得到有序的结果
	不同点：主要是存储元素的类型不同

map：
模板：
	template<>
构造：map<type1, type2> board;
	map构造之后，内部是根据key来进行排序的
插入：
	m.insert(make_pair("apple", "苹果"));
	底层：insert:<iterator, bool>
	返回值：first:iterator，second:bool
重载[]：
	m["apple"] = "苹果"
	m["apple"]-->"苹果"
底层实现：
T& operator[](const K& x)
{
	return (*((this->insert(make_pair(x, T()))).first))
}
1.若key的节点不存在，则调用insert创建一个，并返回true和新创建的迭代器，然后重载的[]再返回second的引用
  若存在，则插入失败返回已存在的key的迭代器和false，重载[]再返回second的引用
2.返回值是引用类型，因此可以直接赋值

set：
作用：去重和排序

底层结构：
AVL树：
	1.二叉搜索树
	3.平衡因子的绝对值不超过1
		平衡因子：每个节点的左右子树之差
	因此AVL树又称：平衡二叉搜索树：查找的时间复杂度O(logN)
AVL插入规则：
	1.按二叉搜索树的规则进行插入
	2.循环判断平衡因子是否被破坏？
		1.没有被破坏：当平衡因子为0则跳出
		2.如果被破坏：旋转
		右单旋：(画个图)
			插入的位置：较高左子树的左侧
			方法：将根节点的左子树的节点向上提
				1.将根的左指向60，60的父指向根
				2.将50的右指向根
				3.原根的可能是子树，50的父指向pp，根的父指向50
				4.修改pp的左/右子树，判断根是pp的左还是右
				5.修改新根和根的右子树的平衡因子为0
		左单旋：
			插入位置：较高右子树的右侧
			方法：
		
		左右双旋：
			插入位置：较高左子树的右侧(直接右单旋之后还是不平衡的)
			方法：将subLR进行两次上提，先对subL左单旋，再对parent右单旋
				1.
				2.
				3.
				4.调整平衡因子
					如果subLR == -1，parent = 1;
					如果subLR ==  1, subL = -1;
		右左双旋：
			插入位置：
			方法：
				1.
				2.
				3.
				4.调整平衡因子
					如果subRL == -1, subR = 1;
					如果subRL ==  1, parent = -1;
AVL树删除规则：
	1.找到待删除的节点
	2.删除
	3.更新平衡因子
*/
/*
AVL树在现实中使用比较少--需要用到二叉平衡搜索树
	原因：复杂度太高：尤其是删除操作：删除，检查平衡因子，旋转，继续向上更新，最差情况需要更新到根结点
	而红黑树使用颜色和性质约定，也可保证高性能

红黑树：
	1.二叉搜索树
	2.限制：
		1.每个节点都有颜色：红色和黑色
		2.性质约束
		3.保证：最长路径中节点的个数一定不会超过
	红黑树实际是一颗近似的二叉平衡树
性质：
	1.每个节点不是黑就是红
	2.根结点一定是黑色
	3.如果一个节点的颜色是红色的，则其孩子节点一定是黑色的，没有连在一起的红色节点
	4.每条路径中黑节点个数一致
课后调研:为什么可保证最长路径中节点个数不超过最短路径节点的两倍？
	红黑树的根结点上还有一个头结点，头->left = begin,头->right = end-1，头结点就是end，头结点是红色
	为什么要给头结点？
		为了快速找到第一个和最后一个节点
节点默认颜色给成红色：为了满足性质4
红黑树插入规则：
	1.按搜索树的规则，进行插入红节点
	2.检测性质3：新插入节点和父节点是否同时为红
		情况一：叔叔节点存在并且也为红(来个图)
			方法：把 parent 和 uncle 改成黑节点，再把 g 变红，继续向上调整，循环条件 parent != head && parent == RED 
		情况二：叔叔节点为黑色 或者 叔叔节点不存在
			叔叔节点不存在，则cur是新插入的
			叔叔节点为黑，则cur不是新插入的，而是被迫改变颜色的，abc一定存在
			方法：把p改成黑，把g改成红，并让g右单旋
				简而言之：parent和g交换颜色，g进行右单旋
		情况三：在情况二的条件下，cur是parent的右子树
			方法：对parent进行左单旋，并且将 cur 和 parent 的指针交换
		这里三种情况只考虑了左半边：右半边只需要反转
		
检测红黑树是否有效
	1.检查根结点是否为黑
	2.没有连在一起的红节点
	3.每条路径的黑节点个数一致
		方法：
			1.空树也是红黑树
			2.检查是叶子节点则停下来，检测是否合理
*/
/*
迭代器是一种设计模式：什么设计模式？？？？list、string里面
迭代器本质：就是指针或者是对指针的封装
	vector 和 string 两个迭代器就是原生态的指针。原因：底层空间是连续的
迭代器的作用：
	让算法(sort,reverse)可以处理任意数据结构中的数据，算法在实现时不用考虑应该面对什么样的数据结构，只关心算法本身
如何给一个容器增加迭代器：
	1.必须要熟悉容器底层的数据结构
	2.原生态指针 <----> 对指针的封装
	3.封装一个迭代器的类
		迭代器的方法：
		构造
		operator*()、operator->()
		operator++()/operator++(int)、operator--()/operator--(int)
		operator!=()/operator==()
	4.取别名：iterator
在Increment()方法里：
	1.如果右子树存在，则在右子树中找最小(最左侧)
	2.如果右子树不存在，则在父节点中找：
		1.node是parent的左树，返回parent 
		2.node是parent的右树，则继续向上走，直到node不是parent的右
	特别的：
		根节点的右树为空：代码循环了
在--方法里
	1.如果左子树存在，则在左子树中找最大(最右侧)
	2.如果左子树不存在，则在父节点中找：
		1.如果node==parent->right，则返回parent
		2.如果node==parent->left，则node=parent,parent=node->parent
	特别的：
		it在begin位置就不能再--了

改造：
	添加：size，empty，swap，clear，find
	改insert：
		返回值：pair<iterator, bool>

封装map和set
	模板类型：
		map：key-value
		set：key
	find方法：参数make_pair一下
插入：map和set插入的值不同，map->first
	方法：
		1.增加模板参数：KOFD
		2.在比较的地方使用KEY(data)<KEY(cur->data)

注意：typename RBT::iterator iterator,让编译器知道不是静态成员
*/