/*
字符串操作：
	C语言标准输入输出错误：stdin、stdout、stderr

strstr(str1, str2)：子串查找-》返回查到的第一个地址
strtok：是用来切分字符串的，首次调用需要传入字符串首地址，后序调用设置为NULL即可
	strtok：会按传入的“”，把原数组中的“”设置成"\0"

start up()调用主函数，程序启动时最先调用的函数
return的返回值是程序的退出码，用来表示程序的退出状态正确与否


mem操作都是按字节来的：
memcpy()：按字节拷贝，与类型无关，可以拷贝一个结构体到另一个结构体
memmove()：
memcmp()：也可比较结构体大小，比较字符串时功能和strcmp相似
	返回值：-1，0，1
memset();
*/

/*
结构体：
	建议写法：定义和重命名不同名
typedef struct Node
{
	int val;
	struct Node* next;
}node_t;
结构体内存对齐：
	CPU访存的地址必须满足4的整数倍
	1.为什么内存对齐：如果不进行内存对齐，因为硬件平台限制会导致访存次数增加
	2.什么是内存对齐：通过牺牲空间的方案换取效率的方案叫内存对齐
	3.怎么去内存对齐：
	对齐规则：
		1.第一个元素不需要对齐地址为0，其他成员变量要对齐到自身类型的整数倍地址
		2.结构体总大小为最大对齐数的整数倍 
		3.嵌套了结构体，则结构体对齐到对齐数的地址(结构体内最大对齐数)，再计算总的最大对齐数
			对齐数：结构体成员的中类型较大数，如果设置了默认对齐数(#pragma pack(4))
几个例子：
#define 

*/
/*

1字节―》2进位的8位-》16进制2位-》8进制三位
位段：
	1.是一种数据的压缩使用，不考虑效率，注重空间使用率，因此不需要内存对齐
	2.位段的可移植性较差
	3.
网络传输：报头就是用位段来设计的，
	第一个32位：4位版本号+4位首部+8位服务类型+16位总长度
	第二个32位：
	第三个32位：
枚举：
	在大型项目中表示特殊状态和返回值


*/