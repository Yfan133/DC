/*
字符串操作：
	C语言标准输入输出错误：stdin、stdout、stderr

strstr(str1, str2)：子串查找-》返回查到的第一个地址
strtok：是用来切分字符串的，首次调用需要传入字符串首地址，后序调用设置为NULL即可
	strtok：会按传入的“”，把原数组中的“”设置成"\0"

start up()调用主函数，程序启动时最先调用的函数
return的返回值是程序的退出码，用来表示程序的退出状态正确与否


mem操作都是按字节来的：
memcpy()：按字节拷贝，与类型无关，可以拷贝一个结构体到另一个结构体
memmove()：
memcmp()：也可比较结构体大小，比较字符串时功能和strcmp相似
	返回值：-1，0，1
memset();
*/



















/*
C内存管理：
	voi* malloc(size_t size);  返回值 void* 意味着必须强转
	free();					   传入的是申请空间的首地址
	Linux和VS的程序地址空间是不同的，我们只关心Linux下的地址空间
	栈随机化：金丝雀技术
	栈空间用户不关心申请和释放，堆空间必须有程序员申请和释放
	如果忘记释放可能会造成内存泄露问题

	为什么要使用动态内存管理？
		非动态内存管理无法知道开辟空间的大小，空间的浪费
	free前后指针所指的地址不变，改变的只是对应指针和内存的关系
	为什么free时不需要传入释放空间的大小？
		free时在内存中看到多释放了一段空间，这部分内存叫cookie，存放了开辟时的源信息，可以在Linux下打印地址看看，相差20
		因此堆空间适合开辟大空间，而栈空间适合开辟小空间
	程序退出内存泄露问题自动消失
	malloc不会初始化，calloc会初始化为 0
	在堆上申请的空间必须是连续的空间，不能是碎片化的
		因此扩容时要考虑后面空间是不是被开辟了
	pre = realloc(ptr, 10000);	不能这样做，因此realloc不一定申请成功，申请失败的时候返回NULL
	程序的地址空间在程序运行期间一直存在

	static修饰：局部变量，全局变量，普通函数的区别
		修饰局部为什么会变成全局？

	柔性数组：
		申请 malloc(sizeof(struct) + 10 * sizeof(int));
	不能用 sizeof 求出 malloc 创建出来的空间大小：
		根本：sizeof是在编译期间确定大小
			  malloc是在运行期间确定











*/