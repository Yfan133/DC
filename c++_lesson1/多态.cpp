/*

		如何获取虚表中的每一项：虚函数的入口地址？
			1.定义子类对象
			2.获取对象前4字节中的内容：虚表地址
				前四字节没办法直接获取，&d--》数值上和对象前四字节起始地址相同，则*(int*)&d-->取到了对象前四字节内容，整型数据
			3.获取虚表中的虚函数入口地址
				cout << hex << *(int*)&b << endl; 以16进位打印
				//cout << typeid(&D::Fun).name() << endl;
				Handler* handler = (Handler*)(*(int*)&b);
				这里为什么要先转换成整型地址再进行解引用，不能直接强转？
					因为整型是4字节，因此强转整型地址就可按4字节进行++ --操作
				(*handler)();	//调用函数

		虚表最下面放的 00 00 00 00 ？？？
			因为虚函数表本质是：函数指针数组：(返回值类型)(*handler[数量])(参数类型)，这个数组最后面放着空指针nullptr
				
		


	
	


4.不同继承方式下的对象模型：带有虚函数
	单继承
	多继承
		子类新增的虚函数的地址放在，第一张虚表的最下面，第二张虚表不会放
		打印一下虚表中的内容，要分两次打印，因为第一张虚表最下面是0000
	菱形继承
	菱形虚拟继承

选择题:
1.用虚函数实现的多态就叫：动态绑定
2.继承：子类和基类是 is-a的关系，子类对象都是基类的对象
  组合：一个类包含另一个类
	都可以实现代码复用，
	下来测试一下：组合的对象，在类外的使用
3.纯虚函数可以有函数体
4.内联函数不能是虚函数：内联函数如果被编译器使用，则会在调用处进行展开，与虚函数调用违背
5.静态成员函数不能是虚函数：
	静态成员函数调用方法：类名::静态成员函数名();
	虚函数调用方式：通过对象来调用则需要this指针，而静态成员没有this
6.虚表：
	基类只有一张虚表，而子类可以有多个虚表
	虚表是编译阶段生成的
	同一个类的不同对象共享一个虚表
7.看一下不进行重写的结果
*/

//深度解析C++对象模型



/*
面试题：
1.什么是多态？
	1.概念：举例一些现实的例子，买票的例子
	2.分类：
		1.静态多态(静态绑定 || 早绑定)：程序在编译期间确定函数的具体行为(具体调用哪一个函数)
			体现：函数重载和模板
			int/double Add(int/double left, int/double right)
			{
				return left + right
			}
			程序在编译时，编译器会对函数的实参类型进行推演，然后根据推演结果选择合适的函数进行调用
			如果没有合适的函数，则编译器会尝试进行隐式类型转化，如果转化成功则调用，否则报错(例如：char -》int可以互相转化，但char* 和 int/char 无法转化)
		2.动态多态(动态绑定，动态联编，晚绑定)：程序在运行期间才能确定函数的具体行为
	3.多态的实现条件---继承体系
	4.伪代码的形式举例子
	5.重写 + override + final
	6.多态的实现原理
		1.基类中含虚函数
		2.基类和派生类的虚表构建过程
		3.虚函数调用原理
			从对象前4字节取出虚表地址
			传参 = this + 函数的实参
			从虚表中找到相应的虚函数
			对该虚函数进行调用
	7.结果对象模型 + 虚表 + 虚函数调用过程
2.什么是重载？重写(覆盖)？重定义(同名隐藏)？
3.类中哪些函数不能作为虚函数？
	1.构造函数：构造函数要初始化对象模型前4字节(虚表)
	2.静态成员函数：
	3.内联函数：如果编译器将函数作为内联进行处理，则内联在编译阶段会在函数调用位置用函数体进行替换
	注意：
		友元函数不是类的成员函数，因此不能作为虚函数。
		赋值运算符重载：可以作为虚函数，但一般情况下不建议设置为虚函数
	虚函数如果要调用，必须从虚表中找到该虚函数地址，找到虚表，而虚表存储在对象前4字节中，则必须有一个对象，而构造函数是给虚表的前4字节赋值
	派生类涉及资源管理时，基类析构必须设置成虚函数
4.多态的缺陷？降低了程序运行效率
	汇编中对于虚函数要增加 mov 指令

课后调研：C语言模拟实现：封装、继承、多态
	1.虚表 -》 函数指针数组
	2.多态的构造函数要初始化虚表地址(对象前4字节)
	  C中用一个初始化函数，将函数指针数组的首地址放到结构体变量的前4字节
	3.对象.成员函数() --》在结构体中增加一些函数指针类型变量
	4.虚函数的调用过程：参考打印虚表
*/

































