/*
抽向类概念：
	1.将包含纯虚函数的类称之为抽象类，纯虚函数 ―》 虚函数 后面 + == 0
	2.抽象类不能实例化对象，因为不具体(空间没办法开辟)，但可以创建出指针(指针空间大小一定)
	3.抽象类是一定要被继承的，并且在派生类中要对抽象类进行重写
	4.如果派生类没有对纯虚函数进行重写，则派生也是抽象类

多态的实现原理：
1.对象模型(上面是从基类继承的(虚表地址+成员变量)，下面是派生的成员变量)
		1.前四个字节是虚表地址，在创建对象时，由构造函数进行填充数据，指向虚表，也就是虚表会跟随对象创建而创建
		2.只要类中有虚函数，则会有一份默认的构造函数，如果用户写了构造函数，则编译器会对构造进行改写，增加给前四字节赋值的语句
	
	问题：哪些情况下编译器会生成默认的构造函数？
		为了提高代码运行效率，只有特定情况下才会生成默认构造。
		1.A包含B且B有构造：A类中包含B类的对象，A类没有构造，而B类带有无参或全缺省的构造
		2.B继承自A且A有构造：B类继承自A类，B类没有构造，而A类带有无参或全缺省的构造
		3.虚拟继承中，编译器一定会给派生生成构造函数，用于给对象模型的前4字节填充数据，指向虚基表
		4.类中包含虚函数，则编译器会生成构造函数，用于给对象模型前4字节填充数据，指向虚表
2.虚表的构建过程：带上环境
		1.虚表中只会放置虚函数
		2.并且在对象模型中的顺序和虚函数的定义位置相同
		3.基类的虚表可能和派生的虚表不同：如果派生重写了某个虚函数，则派生的虚表中会用自己的虚函数替换相同偏移量位置的基类虚函数
			D::TestFun1();	派生重写了
			B::TestFun2();	没有重写
		4.如果子类新增了虚函数(基类中没有)：则派生的虚表会把它们放在对象模型最下面

		虚表中放置的是虚函数的入口地址，如果能拿到虚表中的内容，即拿到了虚函数的入口地址，则可以将该函数调用起来
		如何获取虚表中的每一项：虚函数的入口地址？
			1.定义子类对象
			2.获取对象前4字节中的内容：虚表地址
				前四字节没办法直接获取，&d--》数值上和对象前四字节起始地址相同，则*(int*)&d-->取到了对象前四字节内容，整型数据
			3.获取虚表中的虚函数入口地址
				cout << hex << *(int*)&b << endl; 以16进位打印
				//cout << typeid(&D::)
				Handler* handler = (Handler*)(*(int*)&b);
				这里为什么要先转换成整型地址再进行解引用，不能直接强转？
					因为整型是4字节，因此强转整型就拿到了前4字节
				(*handler)();	//调用函数

		虚表最下面放的 00 00 00 00 ？？？
		完整解释：基类继承过程：基类的对象模型中上面是继承自基类，下面是自己的成员。虚表的指针指向基类的虚函数，如果子类重写了，则修改虚表

小结：
	1.虚表是在编译期间生成的，多态是在运行期间体现的
	2.子类和基类不会共用一张虚表，即使虚表中的虚函数地址都一样
	3.相同子类的对象会共用一张虚表，相同基类的对象也会共用一张虚表	
	4.虚表中的内容是只读的，不允许被修改，其放在代码段(常量也在这)

3.多态的实现原理
	1.没有重写的直接call
	2.满足多态的：
		eax保存PB指针地址-》指向的地址：前4字节是虚表
		edx取到了eax中虚表的地址
		ecx寄存器：取到this指针
			每个成员函数都有隐藏的this指针，通过this指针才知道是哪一个对象在调用函数，当前对象的地址就是ecx寄存器传递给this指针的
		eax取到了即将调用的函数的地址
		call eax 直接调用函数
	完整解释虚函数的调用流程：
		1.取对象地址，通过对象前4字节获取虚表地址
		2.传递this指针
		3.通过虚表地址和偏移量，获取虚函数的地址
		4.直接call调用虚函数

	汇编中：dword是什么意思？
	
	b = (B)d;没有产生临时对象，只是把子类中继承的赋值给了b
	B* pb = &d;也没有产生临时对象，因此pb任然指向子类对象
		(B*)&d
	b = (B)d；可能会产生临时对象

4.不同继承方式下的对象模型：带有虚函数
	单继承
	多继承
		子类新增的虚函数的地址放在，第一张虚表的最下面，第二张虚表不会放
		打印一下虚表中的内容，要分两次打印，因为第一张虚表最下面是0000
	菱形继承
	菱形虚拟继承

选择题:
1.用虚函数实现的多态就叫：动态绑定
2.继承：子类和基类是 is-a的关系，子类对象都是基类的对象
  组合：一个类包含另一个类
	都可以实现代码复用，
	下来测试一下：组合的对象，在类外的使用
3.纯虚函数可以有函数体
4.内联函数不能是虚函数：内联函数如果被编译器使用，则会在调用处进行展开，与虚函数调用违背
5.静态成员函数不能是虚函数：
	静态成员函数调用方法：类名::静态成员函数名();
	虚函数调用方式：通过对象来调用则需要this指针，而静态成员没有this
6.虚表：
	基类只有一张虚表，而子类可以有多个虚表
	虚表是编译阶段生成的
	同一个类的不同对象共享一个虚表
7.看一下不进行重写的结果
















*/

//深度解析C++对象模型



/*
面试题：
1.什么是多态？
	1.概念：举例一些现实的例子，买票的例子
	2.分类：
		1.静态多态(静态绑定 || 早绑定)：程序在编译期间确定函数的具体行为(具体调用哪一个函数)
			体现：函数重载和模板
			int/double Add(int/double left, int/double right)
			{
				return left + right
			}
			程序在编译时，编译器会对函数的实参类型进行推演，然后根据推演结果选择合适的函数进行调用
			如果没有合适的函数，则编译器会尝试进行隐式类型转化，如果转化成功则调用，否则报错(例如：char -》int可以互相转化，但char* 和 int/char 无法转化)
		2.动态多态(动态绑定，动态联编，晚绑定)：程序在运行期间才能确定函数的具体行为
	3.多态的实现条件---继承体系
	4.伪代码的形式举例子
	5.重写 + override + final
	6.多态的实现原理
		1.基类中含虚函数
		2.基类和派生类的虚表构建过程
		3.虚函数调用原理
			从对象前4字节取出虚表地址
			传参 = this + 函数的实参
			从虚表中找到相应的虚函数
			对该虚函数进行调用
	7.结果对象模型 + 虚表 + 虚函数调用过程
2.什么是重载？重写(覆盖)？重定义(同名隐藏)？
3.类中哪些函数不能作为虚函数？
	1.构造函数：构造函数要初始化对象模型前4字节(虚表)
	2.静态成员函数：
	3.内联函数：如果编译器将函数作为内联进行处理，则内联在编译阶段会在函数调用位置用函数体进行替换
	注意：
		友元函数不是类的成员函数，因此不能作为虚函数。
		赋值运算符重载：可以作为虚函数，但一般情况下不建议设置为虚函数
	虚函数如果要调用，必须从虚表中找到该虚函数地址，找到虚表，而虚表存储在对象前4字节中，则必须有一个对象，而构造函数是给虚表的前4字节赋值
	派生类涉及资源管理时，基类析构必须设置成虚函数
4.多态的缺陷？降低了程序运行效率
	汇编中对于虚函数要增加 mov 指令

课后调研：C语言模拟实现：封装、继承、多态
	1.虚表 -》 函数指针数组
	2.多态的构造函数要初始化虚表地址(对象前4字节)
	  C中用一个初始化函数，将函数指针数组的首地址放到结构体变量的前4字节
	3.对象.成员函数() --》在结构体中增加一些函数指针类型变量
	4.虚函数的调用过程：参考打印虚表
*/

































