/*
(多态就是对继承的扩展，既想拥有基类的一部分内容，又想在某些函数中添加独立的处理方式)
1.什么是多态？(标明环境)
	通俗来说就是多种形态，完成某种行为时，不同对象去完成时会产生不同的结果
2.多态分类
3.多态实现条件
	前提：必须在继承方式下
		1.基类中必须有虚函数，子类必须要对基类中的虚函数进行"重写"
		2.虚函数调用：通过"基类的指针"或者"引用"来调用虚函数，因为基类的指针是可以指向子类对象的
4.多态体现：
	1.程序运行时才能体现多态，根据指针或者引用指向不同类的对象调用对应类的虚函数
	2.编译阶段，只进行语法检测,编译器不知道指针指向的是哪一个类对象

5.重写 he 虚函数
	虚函数：被virtual关键字修饰的成员函数称之为虚函数
	重写：
		1.一定是子类对基类中的虚函数进行重写，如果基类的成员函数不是虚函数则一定不是重写
		2.子类虚函数必须要与基类虚函数的原型一致，返回值类型、函数名(参数列表)必须完全一致
			特例：
				协变："基类"虚函数返回"基类的"指针或者引用，"子类"虚函数返回"子类的"指针或者引用
				析构函数：只要基类中的析构函数是虚函数，子类析构函数给出之后就对基类析构进行重写了(函数名不同，但也构成重写)
注意事项：
	1.如果子类涉及资源管理，基类中析构函数必须设置为虚函数，否则可能造成内存泄露
		原因：基类指针指向动态开辟的子类地址，delete时如果基类中的析构不是虚函数(没有构成重写)，子类的动态资源则不能完全释放
		编译器会先调用子类中的析构函数，再调用基类的析构函数
	2.重写后，子类虚函数和基类的虚函数访问权限可以不同，也不影响调用
		
6.检测虚函数是否重写成功
	override 和 final
	override：让编译器在编译期间，帮助检测子类是否对基类的虚函数重写成功
		virtual void TestFunc() override
	编译器在编译期间：回到基类中找virtual void TestFunc()
		找到：重写成功，通过编译
		没找到：重写失败，编译失败
	override关键字只能修改子类中的虚函数
	
	final：
		1.可以修改类，表明该类不允许被继承
		2.可以修饰虚函数，表明虚函数不能被子类重写
7.函数重载，同名隐藏(重定义)，重写(覆盖)的区别
	1.函数重载：相同的作用域，函数名相同，参数列表不同则构成重载，与返回值无关
		在继承体系下函数的作用域不同，因此不是函数重载
	2.同名隐藏：成员变量或者成员函数
	  重写：只能是成员函数
	  在继承体系中，基类和子类中两个成员函数名相同，则不是重写就是同名隐藏
注意：
	1.如果没有写 virtual 则产生同名隐藏
	2.引用不可缺！！！
	3.子类涉及资源管理，基类析构必须为虚函数
*/
/*
抽向类：将包含纯虚函数的类 称之为

虚表中的虚拟地址是无法修改的
子类的虚表先继承父类的虚表，再将对应重写的函数改成自己的函数入口地址
*/


/*
多态在强转时不会生成新的一份拷贝！！
但其他的按理说会生成一份拷贝

*/



/*
面试题：
1.什么是多态？
	1.概念：举例一些现实的例子，买票的例子
	2.分类：
		1.静态多态(静态绑定 || 早绑定)：程序在编译期间确定函数的具体行为(具体调用哪一个函数)
			体现：函数重载和模板
			int/double Add(int/double left, int/double right)
			{
				return left + right
			}
			程序在编译时，编译器会对函数的实参类型进行推演，然后根据推演结果选择合适的函数进行调用
			如果没有合适的函数，则编译器会尝试进行隐式类型转化，如果转化成功则调用，否则报错(例如：char -》int可以互相转化，但char* 和 int/char 无法转化)
		2.动态多态(动态绑定，动态联编，晚绑定)：程序在运行期间才能确定函数的具体行为
	3.多态的实现条件---继承体系
	4.伪代码的形式举例子
	5.重写 + override + final
	6.多态的实现原理
		1.基类中含虚函数
		2.基类和派生类的虚表构建过程
		3.虚函数调用原理
			从对象前4字节取出虚表地址
			传参 = this + 函数的实参
			从虚表中找到相应的虚函数
			对该虚函数进行调用
	7.结果对象模型 + 虚表 + 虚函数调用过程
2.什么是重载？重写(覆盖)？重定义(同名隐藏)？
3.类中哪些函数不能作为虚函数？
	1.构造函数：构造函数要初始化对象模型前4字节(虚表)
	2.静态成员函数：
	3.内联函数：如果编译器将函数作为内联进行处理，则内联在编译阶段会在函数调用位置用函数体进行替换
	注意：
		友元函数不是类的成员函数，因此不能作为虚函数。
		赋值运算符重载：可以作为虚函数，但一般情况下不建议设置为虚函数
	虚函数如果要调用，必须从虚表中找到该虚函数地址，找到虚表，而虚表存储在对象前4字节中，则必须有一个对象，而构造函数是给虚表的前4字节赋值
	派生类涉及资源管理时，基类析构必须设置成虚函数
4.多态的缺陷？降低了程序运行效率
	汇编中对于虚函数要增加 mov 指令

课后调研：C语言模拟实现：封装、继承、多态
	1.虚表 -》 函数指针数组
	2.多态的构造函数要初始化虚表地址(对象前4字节)
	  C中用一个初始化函数，将函数指针数组的首地址放到结构体变量的前4字节
	3.对象.成员函数() --》在结构体中增加一些函数指针类型变量
	4.虚函数的调用过程：参考打印虚表
*/