/*

	2.怎么扩容？(注意取模新的size，原空间元素位置发生改变)
		
		2.开散列(链地址法)：(没有必要新创建哈希节点，直接将原始指针数组中的节点链接到新数组中)
			1.创建一个容量为2*size的哈希表(vector)，并且将旧表中的哈希节点插入到新表中
			2.交换两个变量，因此扩容函数结束时会释放临时变量
		3.提供素数表：(容量为素数)
			原因：只能被1和本身整除，因此造成哈希冲突的可能性降低


	3.怎么查找？
		1.闭散列：
			1.通过哈希函数计算哈希位置，从哈希位置开始寻找如果为空都没找到则返回 nullptr

	4.怎么删除？

	5.为什么闭散列的负载因子控制在0.7，而开散列控制在1，甚至1以上？
		因为开散列就算产生了哈希冲突，也不会占用其他元素的位置
		从整体来说：开散列所用到的空间比闭散列要小，并且不会产生数据堆积

看到 1.43 封装 unordered_map
如果遇到字符串，需要对字符串进行转换

	6.当一个单支不断变长，但还没达到扩容条件时，会影响哈希性能
		解决：将链表转化成红黑树存储起来，节点个数 > 8

	7.
*/









/*
补充：适合数据量比较小
	1.跳表：搜索时间复杂度：O(logN)--->有序--->双向链表的基础上进行的改造
	  跳表特性和红黑树很像
	2.trie树--->字典树--->找字符串前缀

数据量比较大：海量数据保证快速查找：在数据的基础上建立索引
	索引：也是一种数据结构，从索引是否会发生改变分为：静态索引和动态索引
		静态索引：索引结构不会发生改变--->书籍的目录结构
		动态索引：索引结构可能发生变化
			最常见的数据结构：B树


*/

/*
位图：
	1.开辟位图：

	1.整数的位置(哪一块位图)：n / 32
	2.整数位置中具体的bit位置(位图的哪一个位置)：n % 32
获取某个bit位置的值：
	整数 >> (x - 1) & 1
位图：
	适合场景：大数据量，数据不重复，存放信息简单，非负数

布隆过滤器：
	场景：怎么区分垃圾邮件 或者 抖音视频重复内容的过滤？
	解决：记录之前出现过的元素
	记录方法：位图：查询效率高并且存储空间要求小，把对应位置置1，如果出现重复则过滤
	缺点：数据不能重复，并且必须是整数数据
	原理：
		1.首先视频标题等是字符串类型
		2.将字符串用哈希函数转化为整数类型，再将位图对应位置 1
			缺点：可能哈希函数可能映射同一整数，产生冲突
	
	引出：布隆过滤器
	概念：通过多个位置的映射存储元素位置
	特点：概率型数据结构，99%情况下是正确的，1%可能失败
		绝对正确：如果位图中相应位置都0，则说明数据没有出现过，绝对正确
		可能错误：如果位置中找到了几个映射位置都是1，该数据不一定存在
			原因：可能是其他的映射，将该位置 1 。根本原因：存在哈希冲突
	原理：
		1.通过多个哈希函数，映射多个位置，并将多个位置都置1
		2.因此：映射位置越多，则发生哈希冲突的概率越小
	查找：
		1.通过多个哈希函数，检查多个位置



*/