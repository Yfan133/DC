/*
补充：适合数据量比较小
	1.跳表：搜索时间复杂度：O(logN)--->有序--->双向链表的基础上进行的改造
	  跳表特性和红黑树很像
	2.trie树--->字典树--->找字符串前缀

数据量比较大：海量数据保证快速查找：在数据的基础上建立索引
	索引：也是一种数据结构，从索引是否会发生改变分为：静态索引和动态索引
		静态索引：索引结构不会发生改变--->书籍的目录结构
		动态索引：索引结构可能发生变化
			最常见的数据结构：B树

哈希表(散列表)
哈希函数(散列函数)
哈希映射
哈希：查询时间复杂度：O(1)
	存储数据时，将数据与其存储结构之间建立一种一一对应的映射关系，查找时再按照该映射关系进行查找
	插入：
		1.使用data % 表格容量来计算元素应该放在表格的什么位置
		2.将data插入到表格的pos位置
	查找：
		1.使用data % 表格容量pos--->data应该在表格的pos
		2.在表格的pos位置检测是否为data元素
哈希冲突(碰撞)：不同元素在插入哈希表中时，通过哈希函数计算出了相同位置。
	哈希冲突是一定要被处理的，否则：可能会破坏哈希结构或者影响查找结果
解决哈希冲突：
	1.哈希函数：哈希函数设计是否合理，如果不合理则重新设计
		1.哈希函数的值域一定要在表格的范围之内(防止取模之后还是越界)
		2.哈希函数产生的哈希地址要尽可能均匀
		3.哈希函数要尽可能简单
	  常见哈希函数：
		直接定址法：线性函数：HashPos = Ax + B
			适用场景：数据量小，且连续
	  注意：
		哈希冲突只能降低出现概率，但是不能绝对避免
	2.处理哈希冲突的方式：
		1.闭散列：从发生哈希冲突的位置开始，找下一个空位置插入
			方法：
				1.线性探测：逐字的往后找位置，查找到哈希表末尾时，如果还没找到，要重新定位到数组首部
					线性探测的缺点：容易产生数据的堆积(堆在一坨)
					插入规则：(三种位置状态)
						1.通过哈希函数找到相应位置
						2.循环判断当前位置状态是否为空
							如果为空则插入，并将状态改成EXIST
							如果不为空：继续向后检查
					删除规则：
						1.将位置的状态设置为delete
				2.二次探测(以平方探测)：pos1 = pos0 + 2i+1
					找位置方法和线性探测不同：当前位置=上次位置+2i+1
					注意：超过容量之后要取模容量大小
		哈希负载因子：有效元素的个数 / 表格总容量
		一般情况下线性探测的负载因子控制在 0.7，二次探测的负载因子控制在 0.5 ~ 0.6
		哈希优点：查询速度O(1)
		缺点：空间利用率低
		
		2.开散列：链地址法，原理：链表集合将发生冲突的元素挂在同一个链表中，哈希表中没有直接存储元素，而存储的是链表首节点的地址
		





















*/