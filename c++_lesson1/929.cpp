//this指针存储在哪？
//this指针可以为空nullptr
//为什么要内存对齐？
//
//默认对齐参数？如何对齐设置？默认对齐设置可以设置为任意值吗？
//vs:8字节       #prgma pack(4)     必须设置成2的n次方
//怎么求结构体内成员变量的起始偏移量？offsetof(AA.c)模拟实现（百度笔试题）
//什么是大小端？写一个程序判断机器的大小端？（多种方法）说一个情景要考虑大小端问题。大小端和操作系统有没有关系
////////////////////////////////////////////////////////////////////////////
/*
拷贝构造函数
用户没有显示定义时默认给d2设置成和d1一样
用户定义了拷贝构造函数时，将不会运行默认的
Data(const Data& d){}一般情况下加const，不修改传参的内容，增加安全性
不能省略&引用标记，若省略则会无限调用Data()构造函数
Data d2(d1);用d1的成员变量初始化d2

默认拷贝构造函数在底层用的是同一块堆内存空间，析构函数释放时会被释放两次而报错
默认拷贝构造函数是按浅拷贝方式实现的，后果：多个对象用的同一份资源(地址)，被释放多次会引起代码崩溃
浅拷贝：将一个对象中的内容原封不动的拷贝到另一个对象中
类中涉及内存管理时，拷贝构造函数必须显示实现

赋值运算符的重载：默认直接把d2的内容赋值给d1(浅拷贝)，且d1原资源丢失，内存泄露
编译器生成的赋值运算符重载是按浅拷贝的方式实现的

Data d1,d3;
调用赋值运算符的重载
如果一个类没有显示实现赋值运算符重载函数，则编译器

d1=d3;

如果类中涉及到资源管理时，赋值运算符重载必须显示定义
赋值运算符重载与函数重载没有任何关联
函数重载：相同作用域，函数名相同，参数列表不同

=就是赋值运算符
运算符重载不等于函数重载
可以提高代码的可读性
返回值类型operato操作符
bool operator==(const)

*/