//this指针存储在哪？
//this指针可以为空nullptr
//为什么要内存对齐？
//
//默认对齐参数？如何对齐设置？默认对齐设置可以设置为任意值吗？
//vs:8字节       #prgma pack(4)     必须设置成2的n次方
//怎么求结构体内成员变量的起始偏移量？offsetof(AA.c)模拟实现（百度笔试题）
//什么是大小端？写一个程序判断机器的大小端？（多种方法）说一个情景要考虑大小端问题。大小端和操作系统有没有关系
////////////////////////////////////////////////////////////////////////////
/*
一个类中有6个默认的成员函数：1.初始化和清理(构造函数和析构函数)
构造函数前不能加返回值类型，void也不行，在对象的生命周期内只调用一次，对象实例化时由编译器自动调用对应的构造函数并设置初始值
构造函数可以重载（对象实例化但不初始化时）Data(){}
Data d3();这样做编译器会认为它是函数的声明
用户没有显示定义任何构造函数---显示：用户没有写，编译器会自动生成一个无参的默认构造函数
Data d；类中没有显示定义构造函数，但类任然可以创建对象，编译器会调用Data类的无参默认构造函数
但当类中显示定义了构造函数时，编译器不会生成默认构造函数
无参的构造函数和全缺省的构造函数不能同时定义，当定义无初始值对象时，编译器不知道该调用无参还是全缺省
创建哪个类的对象编译器就会调用哪个类的构造函数

析构函数:没有返回值类型
~SeqList()

拷贝构造函数
用户没有显示定义时默认给d2设置成和d1一样
用户定义了拷贝构造函数时，将不会运行默认的
Data(const Data& d){}一般情况下加const，不修改传参的内容，增加安全性
不能省略&引用标记，若省略则会无限调用Data()构造函数
Data d2(d1);用d1的成员变量初始化d2

默认拷贝构造函数在底层用的是同一块堆内存空间，析构函数释放时会被释放两次而报错
默认拷贝构造函数是按浅拷贝方式实现的，后果：多个对象用的同一份资源(地址)，被释放多次会引起代码崩溃
浅拷贝：将一个对象中的内容原封不动的拷贝到另一个对象中
类中涉及内存管理时，拷贝构造函数必须显示实现

赋值运算符的重载：默认直接把d2的内容赋值给d1(浅拷贝)，且d1原资源丢失，内存泄露
编译器生成的赋值运算符重载是按浅拷贝的方式实现的

Data d1,d3;
调用赋值运算符的重载
如果一个类没有显示实现赋值运算符重载函数，则编译器

d1=d3;

如果类中涉及到资源管理时，赋值运算符重载必须显示定义
赋值运算符重载与函数重载没有任何关联
函数重载：相同作用域，函数名相同，参数列表不同

=就是赋值运算符
运算符重载不等于函数重载
可以提高代码的可读性
返回值类型operato操作符
bool operator==(const)

*/