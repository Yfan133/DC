//为什么要内存对齐？
//默认对齐参数？如何对齐设置？默认对齐设置可以设置为任意值吗？
//vs:8字节       #prgma pack(4)     必须设置成2的n次方
//怎么求结构体内成员变量的起始偏移量？offsetof(AA.c)模拟实现（百度笔试题）
//什么是大小端？写一个程序判断机器的大小端？（多种方法）说一个情景要考虑大小端问题。大小端和操作系统有没有关系？
//写博客NULL和nullptr的区别
/*
在C语言中 NULL是((void*)0)类型，在使用int *p=NULL；时NULL被隐式转换成int* 类型。但C++中NULL是0，无法进行隐式转换
因此C++中引入了nullptr来表示空指针，内部实现采用了模板类型，根据参数列表返回相应类型的空指针
*/
////////////////////////////////////////////////////////////////////////////


/*
动态内存管理，内存分布
查询Linux下栈和堆的默认空间大小
Linux下栈空间大小8192kb=8M
Windows下栈空间  1024kb=1M
内核				共4G
环境变量，环境参数
栈					栈帧：存放函数的参数，局部变量，寄存器的信息 (函数结束，栈帧释放)
共享区
堆					堆区：动态内存申请，malloc,calloc,realloc，必须用free释放
数据区				全局变量，被static修饰的数据  (生命周期和程序一致，程序退出数据清空)
代码区				代码和只读常量
数据类型不同，对数据的管理方式也不同，所以要划分不同区域
总结：sizeof和strlen的区别？
sizeof开辟的空间大小
strlen遇到‘\0’停下
malloc，calloc，realloc返回值类型都是void*，接收时必须强转(type*)
malloc(size);
calloc(num,size);并会给内容初始化成0
realloc(*p,size);将p指向的堆空间大小调整到size字节(扩容或缩小)，如果p指针为NULL，则realloc功能和malloc相似，直接申请空间并返回void*
若扩容很大，且新空间会占用其它未释放的内存空间，编译器会在内存新开一个空间并把原空间数据拷贝过来，然后释放原空间

C++中用malloc在堆上创建的对象，并不是真正的对象因为没有调用构造函数，而是与类空间大小相同的东西，在free是
C++动态内存管理方式：申请单个类型的空间：new   释放单个类型空间：delete
					 申请连续类型的空间：new[] 释放连续类型空间：delete[]
int* p1=new int(10);					 用10初始化
int* p2=new int[10]{1,2,3,4,5,6,7,8,9,0};申请连续空间并初始化
delete p1；A
delete[] p2;
new是C++中的一个关键字，malloc是库函数内的，因此要头文件引入
new不需要判空，malloc必须判空，new内部实现不存在返回空的情况
Test* p1=new Test(100);					//会调用构造函数(类内成员t被初始化成1)，因此生成的为对象
Test* p2=(Test*)malloc(sizeof(Test));	//不会调用(类内成员t没有初始化)，因此只能称为和类类型大小相同的堆空间
delete p1;								//会调用析构函数，清理
free(p2);								//只会释放开辟的空间
new/delete  new/delete[]  malloc/free  一定要匹配使用，否则程序可能会崩溃或者内存泄露
写博客有没有内存泄露，如何检测内存泄露在哪，为什么自定义类型(类)没有匹配使用会崩溃？
new的工作方式：
1.申请堆空间（为什么new申请的空间不用判空）
	调用void* operator new(size_t size)申请空间--->内部使用了malloc，失败(内存资源占满)则调用_callnewh(size)函数(用户提供的解决内存不足措施)，用户实现了执行，失败则抛出bad_alloc异常
2.调用构造函数对申请的空间进行初始化
delete的工作方式：
1.调用析构函数，清理对象中资源
2.调用void operator delete(void* p);内部使用--->free() 释放空间
new T[N]
1.申请空间，调用void* operator new[](size_t size);申请空间
operator new[] --->内部调用了operator new函数
2.调用N次构造函数，初始化N个对象
delete[] p
1.调用N次析构函数对p所指向的空间资源进行清理
2.调用void operator delete[](void* p)对p所指向的空间进行释放 --->内部调用了operator delete函数

问题：既调用了析构函数释放空间，又调用delete释放空间，不会因为释放同一空间两次而崩溃吗？
析构是清理N个对象内部的资源(成员变量)，delete是释放空间（清除对象）

new/delete 是关键字，也可以成为操作符--new 操作符
在C++中一般不对四个operator进行重载，除非特殊要求，打印new创建的位置
用malloc开辟的类空间不能称为对象，可以用new(pt) Test(100)去用构造初始化
但不能直接用free()释放
pt->~Test();
free(pt);		先析构再释放就可以完成工作了
也就是说new 相当于---> 先malloc 再new+构造
	 delete 相当于---> 先析构   再free()
*/
//快捷键alt+鼠标拖动
//编译器中显示指针空间,监视p1,10
/*
malloc 创建的在内存上面有个结构体，保存所创建空间大小为32字节，下面4个字节以防越界
placement new ---定位new表达式
内存池---内存管理，创建的空间给类分配时，要定位new表达式，执行构造函数初始化成对象
new(地址)T(参数)： 1.调用operator new()函数  （用户重载后的，不用malloc）
				   2.
malloc申请的一定在堆上，new的可能在自由存储区上(用户把new重载之后，new可能在栈或者磁盘上开辟空间)
查资料：深度理解内存泄露
内存泄露：因错误造成程序未能释放不再使用的内存，造成丢失对该内存的使用，会使程序越来越卡
1.堆内存泄露
	
2.系统资源泄露
	
*/
/*



seqlist不是真正的类名而是类模板的名字，seqlist<T>这才是类名
在主函数中定义:seqlist<int> s1;
seqlist<int> s1;  -->  A s1;
模板会根据参数类型，进行推演，并调用对应的
T& operator[](size_t index)	//返回引用，如果不是引用的话会临时拷贝一份，则s1[0] = 10;这段代码报错
{
	assert(index< _size);
	return _arr[index];
}
*/
/*
STL	面试笔试重点：
什么是STL？
1.C++标准模板库 --->里面代码都是按照模板来实现的
通俗说：就是对常见数据结构的封装(顺序表，链表，栈和队列，二叉树，哈希表等)
	还提供了一些通用类型的算法(通用：1.任意类型的数据都能处理 2.与数据结构无关，什么数据存储的方式(数据结构)都能处理)，而且这些算法都非常灵活(算法是升序还是降序，是删除偶数还是奇数，这种选择都通过用户所传递的参数来确定)
详细说：六大组件(模块)
容器：对常见数据结构的封装--->组织数据
	序列式容器(线性结构)：
	vector:动态类型的顺序表
	list:带头节点的双向链表
	deque:动态的二维数组
	array:静态顺序表
	forward_list:带头节点的单向链表
	算法：1.与数据结构相关的：各个容器的接口
		  2.与数据结构无关的通用算法:sort/find
	迭代器：帮助算法遍历数据，可能先判断数据存储类型，然后按相应方法遍历
	适配器/配接器：stack和queue，里面封装了链表
	空间配置器：用来进行申请和释放空间，以及对这些空间进行管理

C语言没有字符串类型："abcdef"

	关联式容器：
采用容器来组织数据
	算法：与数据结构相关的
			
*/
/*
string类：一种动态(malloc,calloc,realloc等)类型的顺序表---存储字符类型的元素
			一段连续的空间
常用接口
构造析构---构造一个string类型对象
迭代器
容量
元素访问：支持随机访问+operator[](size_t index)--->跟assert用法差不多
						at--->很少用，错误时报异常out_of_range
string类型的对象遍历
1.for()
2.范围for：auto 内部实现也是迭代器
3.迭代器：

创建string s("hello world");创建一个字符串类型
长度s.length();--->不带'\0'
长度s.size();--->和length用法一致，为什么加size，因为容器中有很多写的size，为了让参数同一，加了个size成员
清空s.clear();清空后字符串里仍有一个'\0'，但size=0
扩大或缩小有效长度s.resize(size_t n, char c);修改有效元素(size)到n个，扩大并用c来扩充，若扩大size大于或者等于容量则容量增大。缩小到n，则有效元素减少(size)，后面的内容丢失，但容量不变
				  s.resize(size_t n);没有给出扩充字符c，扩容到n，则用'\0'补全。缩小一般用不传参的
resize扩大步骤：和顺序表的扩容一样,申请新空间，拷贝原空间内容，释放原空间
扩大容量s.reserve(size_t newcapacity);修改容量(capacity)到n个，若n<=原始容量，且n>15则不会发生任何变化，若n<=15则容量才会缩小到15
若n>原始容量，则容量变大

vs中sizeof(string)==28和预期12字节多了16字节，vs为了提高string类型的性能，内部管理了一个固定大小的数组16字节,因此用户在构造string类型对象时，如果有效字符个数小于等于15个时，利用自己内部静态数组保存信息
，超过15个则动态开辟，这样小于等于15就能直接使用，大大的提高了效率
下来调研：strtok
用a.Swap()而不用Swap()原因？
个人猜想：自己定义的函数运行时开辟额外的函数调用栈浪费时间空间
怎么将string类型转换成c里面的字符类型？
int value=atoi(s.c_str());
其他方法？

STL解决问题：
1.找一个字符串的子串
	先获取特定子串的位置，用
2.找最后一个单词(每个单词中间以空格分割，多行输入)
	cin是以空格为结束标志的，无法接收空格分割的
	解决：1.用gets()可以，但太浪费空间了
		  2.getline(cin，s);
	多行输入while(getline(cin,s))
3.将用户所给的单词输出
	while(cin>>)

s1>s2,这种比较和strcmp
课后调研：
为什么不选择以固定步长进行扩容？
成倍的扩容方式可以保证常数的时间复杂度，而固定步长却只能达到O(n)的时间复杂度，因此采用成倍的方式进行扩容
为什么vs1.5倍，Linux2倍
如果以大于两倍的方式进行扩容，那么新申请的空间会大于之前分配内存的综合，导致原始分配的内存不能被使用

iterator:迭代器 sub:子
push_back：插入一个字符
append：追加字符串  
+=：追加字符串
find  找到返回该字符串的位置，否则返回npos(可能其本质就是0)
substr：从某个位置开始截取后面n个字符串（子字符串）
erase
问题：再C语言中"qwer"是const类型的字符常量，为什么这里可以直接传
个人猜测：编译器会强转成char*类型

*/