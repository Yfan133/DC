/*
继承：
	作用：
	1.实现代码复用,避免代码冗余
	2.保持原有类特性的基础上进行扩展，增加新功能
	3.面向对象设计的层次结构

继承之后：成员变量成员函数都被继承了，sizeof == 父类 + 子类新增的
基类：类似根结点，所有子类的祖先

继承方式：
class Base{};
class Child : 继承权限 + Base
{};

继承规则：
	继承方式：          基类的成员的访问权限 
						public		protected	    private
	   public			public		protected		不可被访问(继承到子类中了)
	protected			protected   protected       不可被访问(继承到子类中了)
	  private			private     private         不可被访问(继承到子类中了)
	
	注意：这里的访问权限是针对类外的访问权限，也就是子类对象在main函数中的权限，子类中还是可以访问父类中public和protected成员的！

如果不写继承权限：class 默认给private的继承权限
				  struct 默认给public

在C++中class 和 struct 的区别
	1.访问权限
	2.继承权限
	3.定义一个模板 template <class T> ，而不能用struct
*/

/*
对象模型：基类和派生类的成员变量在内存中的分布(画个图)

继承规则：
	1.可以用派生类对象给基类对象赋值，反之不行(基类赋值只用派生类中基类的部分)
	2.基类指针可以指向派生类对象，基类可以引用派生对象(基类指针按基类方式解析派生对象)
	3.派生类指针不能指向或引用基类，可以强转地址接收，但在使用时可能崩溃(派生类指针解析时，使用到派生独有是非法空间)

继承时的同名成员变量和成员函数处理规则：
	1.基类和派生中同名的成员同名，基类成员会被隐藏,并不是函数重载，因为两个函数的作用域不用
	2.调用同名成员时，是调用的派生类中的
	3.通过 Derived.Base::fun() 可以访问到基类中的同名对象

派生的构造、拷贝构造、赋值重载规则：
	1.基类没有显示定义构造，或者构造是无参或者全缺省，则派生类不用显示定义构造。但编译器会生成一份默认的派生构造
	2.基类的构造带有参数(不是全缺省)，则派生类必须显示定义构造，并且初始化列表要调用基类构造并传值
	3.派生拷贝构造函数必须调用基类拷贝构造
	4.赋值运算符重载一样，必须调用基类的
默认的派生构造：
	chl()
		: par()			先调用基类的构造
		, a_(随机值)	再初始化派生成员
	{}
显示定义的派生构造：
	chl(int d1, int d2)
		: par(d1)
		, a_(d2)
	{}

派生类的析构规则：
	1.先调用派生的析构清理资源
	2.再调用基类的析构清理资源

其它性质：
	1.友元特性不能被继承：基类的友元函数无法调用派生类的成员
	2.static修饰的成员在基类和派生类中都表示同一地址
*/

/*
多继承规则：
	1.继承多个基类时，每个都要加权限，否则默认给private
	2.继承的顺序决定了，不同基类的成员在派生中的位置，也就是对象模型中的位置

*/