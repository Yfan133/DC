/*
继承：
	作用：
	1.实现代码复用,避免代码冗余
	2.保持原有类特性的基础上进行扩展，增加新功能
	3.面向对象设计的层次结构

继承之后：成员变量成员函数都被继承了，sizeof == 父类 + 子类新增的
基类：类似根结点，所有子类的祖先

继承方式：
class Base{};
class Child : 继承权限 + Base
{};

继承规则：
	继承方式：          基类的成员的访问权限 
						public		protected	    private
	   public			public		protected		不可被访问(继承到子类中了)
	protected			protected   protected       不可被访问(继承到子类中了)
	  private			private     private         不可被访问(继承到子类中了)
	
	注意：这里的访问权限是针对类外的访问权限，也就是子类对象在main函数中的权限，子类中还是可以访问父类中public和protected成员的！

如果不写继承权限：class 默认给private的继承权限
				  struct 默认给public继承权限

在C++中class 和 struct 的区别
	1.访问权限
	2.继承权限
	3.定义一个模板 template <class T> ，而不能用struct
*/

/*
对象模型：基类和派生类的成员变量在内存中的分布(画个图)

继承规则：
	1.可以用派生类对象给基类对象赋值，反之不行(基类赋值只用派生类中基类的部分)
	2.基类指针可以指向派生类对象，基类可以引用派生对象(基类指针按基类方式解析派生对象)
	3.派生类指针不能指向或引用基类，可以强转地址接收，但在使用时可能崩溃(派生类指针解析时，使用到派生独有是非法空间)

继承时的同名成员变量和成员函数处理规则：关键字：__super
	1.基类和派生中同名的成员同名，基类成员会被隐藏,并不是函数重载，因为两个函数的作用域不用
	2.调用同名成员时，是调用的派生类中的
	3.通过 Derived.Base::fun() 可以访问到基类中的同名对象

派生的构造、拷贝构造、赋值重载规则：
	1.基类没有显示定义构造，或者构造是无参或者全缺省，则派生类不用显示定义构造。但编译器会生成一份默认的派生构造
	2.基类的构造带有参数(不是全缺省)，则派生类必须显示定义构造，并且初始化列表要调用基类构造并传值
	3.派生拷贝构造函数必须调用基类拷贝构造
	4.赋值运算符重载一样，必须调用基类的
默认的派生构造：
	chl()
		: par()			先调用基类的构造
		, a_(随机值)	再初始化派生成员
	{}
显示定义的派生构造：
	chl(int d1, int d2)
		: par(d1)
		, a_(d2)
	{}

派生类的析构规则：
	1.先调用派生的析构清理资源
	2.再调用基类的析构清理资源（在子类的析构中不需要显示定义出来，编译器自己调用）

其它性质：
	1.友元特性不能被继承：基类的友元函数无法调用派生类的成员
	2.static修饰的成员在基类和派生类中都表示同一地址，即静态成员在整个继承体系中只有一份

课后调研：构造函数，拷贝构造函数，赋值运算符重载，析构函数 是否继承到了子类中？
*/

/*
多继承规则：
	1.继承多个基类时，每个都要加权限，否则默认给private
	2.继承的顺序决定了，不同基类的成员在派生中的位置，也就是对象模型中的位置
菱形继承：
		A
	B1		B2
		C
	问题：
		C中继承了B1和B2的a，在使用时造成二义性的问题，编译器不知道调用哪一个a
	解决：
		1.加作用域限定符
		2.虚拟继承，从根本上解决了二义性问题，基类中的成员变量在C中只存储了一份，而且在最下面

虚拟继承：(有构造函数，给了随机值)
	特点：
	1.虚拟继承的对象模型会多出4字节(地址)
	2.编译器给子类生成了一份构造函数，如果用户显示定义出了构造函数，则编译器会对构造进行修改 
		(目的：给前四字节填充数据，叫"虚基表指针"或者"偏移量表格指针") 画个图：偏移量表格和虚基表，最上面是对自己的偏移量，最下面是对基类部分的偏移量
	3.虚拟继承的对象模型和单继承相反，子类新增在上，基类在下

问题：菱形继承中，最基类的成员变量在子类对象模型中的最下面，所以可以直接访问，那为什么要弄出个虚基表？
面试题：什么是菱形继承？菱形继承存在什么问题？
*/