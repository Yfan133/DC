/*
网络：网络基础1		协议分层、封装与分用
	  网络套接字	简单的IP地址 + 网络字节序 + UDP套接字编程 + tcp套接字编程 + tcp多进程编程
	  网络基础2		应用层 + 传输层
	  网络基础3		网络层 + 数据链路层
	  高级IO

网络基础1：
	背景：
		网络的任务：信息共享，信息交换
		画个图：家网络到城网络
		按返回划分：局域网：几公里  城域网：几十公里  广域网：几百公里  
		长城防火墙：我国的广域网
		Transfer Pacific Cable：太平洋光缆，从青岛上岸，80G/s
		问都哥怎么翻墙？
	网络协议：
		协议：国家事务或者外交场合的正式程序或者规则系统
		画个图：两国友人交流
		协议：通信双方对于通信进行约定，使用一种共同语言来进行有效沟通；
		网络协议：在网络当中通信双方对数据交换和数据传输做出决定
		计算机当中有很多网络协议，将这些网络协议联系在一起，称之为协议簇(TCP/IP)
		参考模型或者体系结构：在协议簇当中，定义各个协议之间的相互关系和协议需要完成的任务
		
	协议分层：
		协议分层就是一种封装，对不同的协议或者服务进行封装
		OSI参考模型(参考意义，实际工业上是没有使用的，因为分层太细节)
			口诀：物数网传会表应
			物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
			前面6层已经被实现了，我们只关心应用层
		TCP/IP五层模型
			物理层，数据链路层，网络层，传输层，应用层(合并会话层，表示层)		

			1.应用层：负责应用层程序之间的数据传输，程序员就是工作在这一层面的，即代码在应用层
				典型的协议：HTTP协议，FTP协议，DNS协议，SMTP协议
			2.传输层：负责端与端之间的数据传输，理解端与端是知道是端口和端口之间传输(端口)
				典型协议：TCP协议和UDP协议
			3.网络层：负责路由选择和地址管理
				典型协议：IP协议，ARP协议，ICMP协议
				典型设备：路由器
			4.数据链路层：负责相邻设备之间的数据帧传输
				典型协议：以太网协议(Ethernet)
				典型设备：交换机
			5.物理层：负责光电信号的传输
				典型协议：以太网协议
				典型设备：集线器

		计算机网络当中两台计算机如何进行通信？IP+port
			IP地址：
				作用：在网络当中唯一标识一台主机
				本质：unit32_t值，无符号4个字节，范围0~42亿
					192.168.113.192 --》点分十进制表示方法，以点分割，每个字节最大能表示的数是255
					192.168.256.113 --》非法IP地址
				源IP地址：当前这个数据从哪一个机器上面来的
				目的IP地址：当前这个数据要去往哪一个机器
			
			PORT：端口
				作用：在一台主机中标识一个进程
				本质：unit16_t，范围0~65536，无符号16位整数，一个端口只能被一个进程所占用，一个进程可以占用多个端口
				使用：网络当中的程序，通信时需要使用端口来进行
				知名端口：(0~1023)，被知名协议所占用
				http协议：80
				https协议：443
				ssh协议：22
				mysql：3306
				oracle：1521
				我们在开发应用程序的时候，杜绝占用知名端口，避免使用熟知软件使用的端口，因为一个端口只能被一个进程所占用

		网络通信中，每一条数据都是需要具备5个信息，我们称之为5元组 = 源IP + 源端口 + 目的ip + 目的端口 + protocol
			源IP地址：src_ip，当前这个数据从哪一个机器上面来的
			目的IP地址：dest_ip，当前这个数据要去往哪一个机器
			源端口：src_port，从源主机上面哪一个进程来的，当回复应答的时候，就知道回复到哪一个进程了
			目的端口：dest_port，去往哪一个主机上面的进程
			协议：protocol，标识使用什么协议

		画个图：网络传输：从数据的封装 到  分用
	
		ip协议分为两个版本：ipv4和ipv6(目前正在使用)
			1.ipv4和ipv6指的是不同版本的ip协议
			2.ipv6并不向下兼容ipv4，因为报头格式不同
			3.ipv4版本的IP地址不够用，无符号32位(0~2^32)大概42亿--》4字节  而当前有60亿人口
			  ipv6版本，无符号128位(0~2^128)--》16字节
	
	画个图：客户端与服务端
	客户端和服务端的概念是相对的
		客户端：主动发起请求的一方，称为客户端
		服务端：被动的在同一个位置上(位置)接收请求的一方，称为服务端
	注意：对外提供服务的端口一般不要变化，否则要通知所有用户来改变端口

	面试题：为什么不使用PID作为请求与主机当中查找进程的标准呢？
///////////////////////////////////////////////////////////////////////////////////
网络字节序：
	前提：
	字节序;CPU对内存当中的数据进行存取的顺序
	大端字节序：低地址存高位
	小端字节序：低地址存低位(小小小)
	画个图：大小端
	如何区分大小端机器？
		union
		{
			int a;		//赋值一个01
			char b;		//如果是01则是小端，不是则大端
		}
		x86_64机器基本都是小端

	网络字节序：大端字节序
		我们在网络传输的过程当中都需要遵循网络字节序
		主机字节序：机器实际的字节序
	字节序转换：
		大端字节序的机器转换网络字节序的时候，无需做任何事
		小端字节序的机器转换网络字节序的时候，需要将小端转化为大端
			uint32_t htonl(unit32_t hostlong)：将32位主机字节序转化为网络字节序，引申含义：大端调用该接口什么都不会发生
			unit32_t ntohl(unit32_t netlong)

	在ifconfig中看到的，172.16.99.129就是IP，它是以点分十进制表示的，比如一个IP是40000001转换成二进制，然后8位一分，总共四字节
	
	 TCP与UDP协议的区别：
		TCP
			面向连接：TCP通信双方在发送数据之前，需要先建立连接，才可以发送数据
			可靠传输：保证TCP数据包一定到达对端
			面向字节流：对于TCP数据可以随意的存取，每一条数据之间是没有间隔的，这也就是TCP粘包问题的万恶之源！
		UDP
			无连接：在发送数据的时候，不需要建立连接，知道对端的IP和端口(port)就可以直接发送数据了
			不可靠：如果在网络传输当中，数据包丢掉了，那就丢掉了，不保证一定到达对端
			面向数据报：UDP在发送数据的时候，是整条交付的

	UDP通信流程&UDP编程接口：
		1.UDP通信流程(画个图socket套接字)








*/
