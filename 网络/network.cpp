/*
网络：网络基础1		协议分层、封装与分用
	  网络套接字	简单的IP地址 + 网络字节序 + UDP套接字编程 + tcp套接字编程 + tcp多进程编程
	  网络基础2		应用层 + 传输层
	  网络基础3		网络层 + 数据链路层
	  高级IO

网络基础1：
	背景：
		网络的任务：信息共享，信息交换
		画个图：家网络到城网络
		按返回划分：局域网：几公里  城域网：几十公里  广域网：几百公里  
		长城防火墙：我国的广域网
		Transfer Pacific Cable：太平洋光缆，从青岛上岸，80G/s
		问都哥怎么翻墙？
	网络协议：
		协议：国家事务或者外交场合的正式程序或者规则系统
		画个图：两国友人交流
		协议：通信双方对于通信进行约定，使用一种共同语言来进行有效沟通；
		网络协议：在网络当中通信双方对数据交换和数据传输做出决定
		计算机当中有很多网络协议，将这些网络协议联系在一起，称之为协议簇(TCP/IP)
		参考模型或者体系结构：在协议簇当中，定义各个协议之间的相互关系和协议需要完成的任务
		
	协议分层：
		协议分层就是一种封装，对不同的协议或者服务进行封装
		OSI参考模型(参考意义，实际工业上是没有使用的，因为分层太细节)
			口诀：物数网传会表应
			物理层，数据链路层，网络层，传输层，会话层，表示层，应用层
			前面6层已经被实现了，我们只关心应用层
		TCP/IP五层模型
			物理层，数据链路层，网络层，传输层，应用层(合并会话层，表示层)		

			1.应用层：负责应用层程序之间的数据传输，程序员就是工作在这一层面的，即代码在应用层
				典型的协议：HTTP协议，FTP协议，DNS协议，SMTP协议
			2.传输层：负责端与端之间的数据传输，理解端与端是知道是端口和端口之间传输(端口)
				典型协议：TCP协议和UDP协议
			3.网络层：负责路由选择和地址管理
				典型协议：IP协议，ARP协议，ICMP协议
				典型设备：路由器
			4.数据链路层：负责相邻设备之间的数据帧传输
				典型协议：以太网协议(Ethernet)
				典型设备：交换机
			5.物理层：负责光电信号的传输
				典型协议：以太网协议
				典型设备：集线器

		计算机网络当中两台计算机如何进行通信？IP+port
			IP地址：
				作用：在网络当中唯一标识一台主机
				本质：unit32_t值，无符号4个字节，范围0~42亿
					192.168.113.192 --》点分十进制表示方法，以点分割，每个字节最大能表示的数是255
					192.168.256.113 --》非法IP地址
				源IP地址：当前这个数据从哪一个机器上面来的
				目的IP地址：当前这个数据要去往哪一个机器
			
			PORT：端口
				作用：在一台主机中标识一个进程
				本质：unit16_t，范围0~65536，无符号16位整数，一个端口只能被一个进程所占用，一个进程可以占用多个端口
				使用：网络当中的程序，通信时需要使用端口来进行
				知名端口：(0~1023)，被知名协议所占用
				http协议：80
				https协议：443
				ssh协议：22
				mysql：3306
				oracle：1521
				我们在开发应用程序的时候，杜绝占用知名端口，避免使用熟知软件使用的端口，因为一个端口只能被一个进程所占用

		网络通信中，每一条数据都是需要具备5个信息，我们称之为5元组 = 源IP + 源端口 + 目的ip + 目的端口 + protocol
			源IP地址：src_ip，当前这个数据从哪一个机器上面来的
			目的IP地址：dest_ip，当前这个数据要去往哪一个机器
			源端口：src_port，从源主机上面哪一个进程来的，当回复应答的时候，就知道回复到哪一个进程了
			目的端口：dest_port，去往哪一个主机上面的进程
			协议：protocol，标识使用什么协议

		画个图：网络传输：从数据的封装 到  分用
	
		ip协议分为两个版本：ipv4和ipv6(目前正在使用)
			1.ipv4和ipv6指的是不同版本的ip协议
			2.ipv6并不向下兼容ipv4，因为报头格式不同
			3.ipv4版本的IP地址不够用，无符号32位(0~2^32)大概42亿--》4字节  而当前有60亿人口
			  ipv6版本，无符号128位(0~2^128)--》16字节
	
	画个图：客户端与服务端
	客户端和服务端的概念是相对的
		客户端：主动发起请求的一方，称为客户端
		服务端：被动的在同一个位置上(位置)接收请求的一方，称为服务端
	注意：对外提供服务的端口一般不要变化，否则要通知所有用户来改变端口

	面试题：为什么不使用PID作为请求与主机当中查找进程的标准呢？
///////////////////////////////////////////////////////////////////////////////////
网络字节序：
	1.前提：
		字节序;CPU对内存当中的数据进行存取的顺序
			大端字节序：低地址存高位
			小端字节序：低地址存低位(小小小)
		如何区分大小端机器？
			union
			{
				int a;		//赋值一个01
				char b;		//如果是01则是小端，不是则大端
			}
		x86_64机器基本都是小端

	2.网络字节序：大端字节序
		小端机器和大端机器进行网络通信时，如果不转换字节序，则会使小端机器很小的数，经过网络传输，被大端机器读出来变成很大的数字
		我们在网络传输的过程当中都需要遵循网络字节序
		主机字节序：机器实际的字节序
	3.字节序转换：
		大端字节序的机器转换网络字节序---》无需做任何事
		小端字节序的机器转换网络字节序---》需要将小端转化为大端
			uint32_t htonl(unit32_t hostlong)：将32位主机字节序转化为网络字节序，引申含义：大端调用该接口什么都不会发生
			
			unit32_t ntohl(unit32_t netlong)；将32位的网络字节序转换为主机字节序
			unit16_t htons(unit16_t hostshort)；将16位的主机字节序转换为网络字节序
			unit16_t ntohs(unit16_t netshort)；将16位的网络字节序转换为主机字节序

	在ifconfig中看到的，172.16.99.129就是IP，它是以点分十进制表示的，比如一个IP是40000001转换成二进制，然后8位一分，总共四字节
	
	 TCP与UDP协议的区别：
		TCP
			面向连接：TCP通信双方在发送数据之前，需要先建立连接，才可以发送数据
			可靠传输：保证TCP数据包一定到达对端
			面向字节流：对于TCP数据可以随意的存取，每一条数据之间是没有间隔的，这也就是TCP粘包问题的万恶之源！
		UDP
			无连接：UDP通信双方在发送数据的之前，不需要建立连接，知道对端的IP和端口(port)就可以直接发送数据了
			不可靠：如果在网络传输当中，数据包丢掉了，那就丢掉了，不保证一定到达对端
			面向数据报：UDP在发送数据的时候，是整条发送整条接收的

UDP通信流程&UDP编程接口：
	1.UDP通信流程
		(画个图UDP，画图更加清晰明了)
		客户端：client
			1.创建一个套接字
			2.绑定地址信息
				一般让操作系统默认分配一个空闲的端口
				注意：一个端口只能被一个进程所绑定
			3.发送数据 ----》接收数据(服务端)
			4.接收数据《---- 发送数据(服务端)
			5.关闭套接字     关闭套接字(服务端)
		服务端：server
			1.创建一个套接字：将创建出来的套接字的进程和网卡建立联系，struct socket{...};
			2.绑定地址信息：port+ip，将端口和进程联系起来，port表明服务端进程在哪一个端口上侦听数据；ip表明服务端进程在哪一个网卡上接收数据
			3.发送数据 ----》接收数据(客户端)
			4.接收数据《---- 发送数据(客户端)
			5.关闭套接字     关闭套接字(客户端)
	2.UDP编程套接字
		1.创建套接字
			int socket(int domain，int type，int protocor)；
				domain：地址域，指定网络层在使用什么协议						
					网络层：AF_INET：IPV4版本的ip协议
							AF_INET6：IPV6版本的ip协议
				type：套接字类型
					传输层：tcp/udp
					SOCK_STREAM：流式套接字--》默认协议是TCP协议,不支持UDP协议
					SOCK_DGRAM：数据报套接字--》默认协议是UDP协议，不支持TCP协议
				protocol：指定套接字所使用的协议
					0：采用套接字的默认协议
					IPPROTO_TCP--》6     TCP协议
					IPPROTO_UDP--》17	 UDP协议
				返回值：返回套接字操作句柄，其实就是一个文件描述符，我们一般称之为套接字描述符
				画个图：(用户空间socket()，内核空间在files结构体指针中，fd_array[]新增了一个元素，相当于打开了一个文件，然后这个文件指向接收和发送缓冲区)

		2.绑定地址信息：
			int bind(int sockfd，const struct sockaddr* addr，socklen_t addrlen)；
				sockfd：套接字操作句柄
				addr：地址信息 ip+port
				addrlen：地址信息的长度
			地址信息解析
				struct sockaddr
				{
					sa_family_t sa_family；		//填充地址域，告诉bind函数，网络层使用什么协议
					char sa_data[14]；			//
				}
				struct sockaddr_in
				{
					
				}
			ipv4版本的地址信息：
				
			内核是通过地址域，来判断版本是哪一个
			bind接口为什么设计为struct sockaddr，而不是设计为struct sockaddr_in，

	3.发送数据
		ssize_t sendto(int sockfd，const void* buf，size_t len，int flags，const struct sockaddr* dest_addr，socklen_t addrlen)
			sockfd：套接字的操作句柄
			buf：要发送的数据，可以发送结构体，可以发送字符串
			len：数据长度
			flags:
				0:阻塞
			dest_addr：目标主机的地址信息，

		画个图：client(客户) 和 server(服务)
		1.UDP没有发送缓冲区，这句话错的，只不过UDP是整条数据发送，所以在发送缓冲区当中打上UDP协议报头之后就提交给网路层了



	4.接收数据
		ssize
				
UDP通信的小demo
	服务端：创建套接字，绑定地址信息，接收数据，发送数据，关闭套接字
	客户端：创建套接字，发送数据，接收数据，关闭套接字

封装接口：
	1.创建套接字
	2.接收&发送数据
	3.


TCP编程流程&TCP接口
	1.创建套接字
	2.绑定地址信息
	3.监听
		告知操作系统内核可以接收新连接
	4.获取连接


TCP针对每个客户端都会创建一个新的套接字，进行1对1服务
UDP是创建了一个套接字服务所有客户端
*/

/*
udp:






*/