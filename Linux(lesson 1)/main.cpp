#include<iostream>
//Linux不以文件后缀区分，加后缀和颜色是为用户区分
//环境变量:就是一个变量,用于存储系统运行的环境参数
//操作指令:env set echo 查看环境变量 export 设置环境变量 unset 删除环境变量
//作用:
//1)通过修改环境变量的值,灵活的配置系统运行参数
//2)子进程会继承父进程的环境变量

///////////////////////////////////////////////////////////
//程序地址空间
//地址:内存地址---对内存以字节为存储单元的一个编号
//
/*
内核空间
环境变量,运行参数
栈(往下生长)
...
...(共享区)
堆(往上生长)
未初始化全局
初始化全局
代码段
*/
//虚拟内存地址空间:可以提高物理内存利用率,虚拟内存是连续的,但实际上在物理内存中是离散存储的
//操作系统的内存管理方式:

/*
分段式:
通过段号查到物理内存地址,再用内存地址+段内偏移量找到对应的物理内存单元
未解决内存利用率低的问题
分页式:
通过页号查到该页号的物理内存地址,再用物理内存地址+页内偏移量()找到对应的物理内存单元
优点:内存块大小跟内存页一样,物理内存块比较小,并且不要求同一进程的多个数据必须在同一个块内,因此分页式实现了数据在物理内存中的离散式存储,提高了内存利用率
页表会在进行内存访问时会进行内存访问权限查询(页表和)
12412
32位操作系统 内存4G/4k == 页表项(页号)的个数 == 2^20 
段页式:

*/
//操作系统中,虚拟内存地址和物理内存地址有一个
/////////////////////////////////////////////////////////////////////
//写时拷贝技术：子进程创建出来之后，与父进程映射访问同一物理内存，当物理内存中数据即将发生改变时(父进程数据发生改变)
//重新为子进程开辟物理内存，拷贝数据过去。好处：防止给子进程创建空间，但子进程不用，降低了进程的创建效率，造成内存冗余数据
//pid_t vfork(void)  会造成死循环(vfork创建的子进程，不能在main函数中使用return退出，因为子进程使用return退出时释放了
//所有资源,父进程运行的时候资源是错误的)


//当父进程在main函数中调用fork函数创建子进程，fork运行完毕之后，父进程应该从调用fork函数的下一步开始执行
//fork父子进程各有各的栈，vfork父子进程共用同一块栈区
//printf打印数据，实际上是把数据交给显示器，让显示器显示。先放入数据缓冲区，等积累到一定数量之后一次性输出，这样做会提高程序运行效率。
//(\n)除了换行的作用之外，还有刷新缓冲区的作用（使数据输出）
//总之vfork父子进程同一空间，fork父子进程不同空间

//进程等待：父进程等待子进程退出，为了获取退出子进程返回值，释放退出子进程的所有资源


//Linux下以.为开头的文件默认不显示(隐藏文件)


//磁盘至少有两个分区：文件交换分区，文件系统分区（且交换分区只有一个，系统分区可以有多个）
//交换分区:作为交换内存使用，通常大小在16G以内，是内存的两倍，超过时相等即可
//文件系统分区：作为文件存储使用
//程序运行，运行信息占用的是内存，内存不够用了，把非活跃区内的数据放入磁盘上（文件交换分区）这样内存就有空间加载新的数据进行处理
//windows下磁盘分了多少分区，就可以有多少盘符，每个盘符都是一个大目录（给某个空间分配文件夹）
//linux下目录结构是惟一的，不会随着分区多少而改变（给某个目录分配空间）
//挂载是指：给某个目录分配一块磁盘空间，这个目录下的文件数据存储的时候就会存储到这个空间中

//目录操作
//绝对路径：以根目录作为起始表达的路径 例：./workspace/
//相对路径：是以某个路径
// .	表示目录自身
// ..	表示目录上一层
//mkdir -p 层层递进创建目录 rmdir -p 层层删除空目录(哪层为空就删除哪一层)
//rm -rf  删除目录及目录内所有文件
//cp -r  层层拷贝目录(文件)
//mv   (剪切)移动目录的位置

//文件操作
//touch  若文件不存在则创建，若存在则刷新文件的时间属性
//cat  分页显示文件内容
//head -n 显示文件前n行
//tail -n 显示文件尾n行
//echo  打印字符串，将数据写入标准输出(显示器设备文件)"sjk666" >> filename 把sjk666写入文件
//stat  查看文件状态
//>>或者>  重定向符号，进行数据流的重定向，文件重定向(echo "1" >> file将原本要写入标准输出的数据写入文件，改变数据的流向)
//>  先清空在输入数据
//>> 直接追加数据
//|  管道符连接两个命令（head -n 23 | tail -n 1）输出第12行

//打包指令
//压缩：将一个文件按压缩算法，将数据从多变少
/*
zip
gzip
bzip2
*/
//打包：将多个文件合并成一个文件
/*
tar  Linux下使用度很高的打包解包工具
-c打包 -x解包 -z打包同时进行gzip格式的压缩解压缩 -j打包同时进行bzip2格式的压缩解压缩 -v显示打包解包信息 -f用于指定tar包的名称，通常作为最后一个选项
tar -czvf new_name file	file				打包
tar -xvf  file(不加格式，则自动检测格式)	解包(默认解压到当前目录下)
*/
//单引号（会消除字符里特殊字符的特殊含义）双引号不会
//grep  从文件里查找匹配的行(文件里找函数)
//-v  反向匹配(不包含的行) -R  对某个目录进行层层寻找(每个文件都要查找)
//例：grep -i "sjk" ./op
//find  在目录中查找指定名称/大小/时间/类型的文件
//find ./ -name"*test*" (**为模糊匹配)  
//find ./ -type d 通过文件类型查找文件 -d -
//find ./ -size -10M  通过文件大小查找10M以内文件--+10M查找超过10M大小的文件
//find ./ -mmin -10  通过文件时间查找 --cmin,mmin,amin--分钟为单位
//
//		  -前面都有一个减号，为**以内
//tab  快捷键，文件名自动补全
//ctrl+c --中断当前操作

//shell的理解
//操作系统内核与用户之间的桥梁---命令行解释器
//shell会捕捉用户的标准输入，得到字符串，通过字符串判断用户想要干什么
//终端能执行命令就是因为运行了一个程序--shell--命令行解释器
//Windows下的shell就是操作界面(和操作内核沟通的桥梁)
//权限：限制用户权利的东西
//文件权限对用户：所有者-u，所属组-g，其他用户-o
//文件权限对操作：可读-r，可写-w，可执行-x
//在系统中权限的存储：使用二进制
// rw-rw-r--  --> 110 110 100  占用空间小，易操作
//也可以用八进制表示用户的权限110 110 100  --> 6 6 4

//文件访问权限指令
//umask -S(人性化显示) 查看或者设置文件的创建权限掩码
//umask 八进制掩码，权限计算方法：777-八进制掩码
//创建好的文件进行权限修改
//chmod 777 hello.txt 直接使用八进制数进行修改
//chmod a-x hello.txt 对某个用户进行权限修改
//文件用户信息修改
//chown username filename 修改文件所有者(只能使用root修改)
//chgrp username filename 修改文件所属组
//文件权限沾滞位：特殊的权限位--主要用于设置目录沾滞位，其他用户在这个目录下能够创建文件，可以删除自己的文件，但不能删除别人的
//chmod +t filename

//vim 是一个命令行编辑器，不能使用鼠标(使用鼠标是无效的)
//vim具有多种操作模式：12种，常用的三种：插入模式，普通模式，底行模式
//普通模式：进行文本常见的操作-复制，剪切，粘贴，删除，撤销，返回，文本对齐，光标的快速移动
//底行模式：进行文本的保存退出，以及文本的匹配查找替换操作
//vim filename 若文件不存在创建，存在则打开，打开后处于普通模式
//:q!强制退出(不保存)
//i进入插入模式，a后移一个并插入，o新建一行并插入
//光标移动：hjkl上下左右，w/b按单词移动，ctrl+f/b上下翻页
//文本操作：yy/nyy-复制；p/P-粘贴,dd/ndd删除/剪切,x-删除光标所在字符,dw-删除单词
//u-撤销，ctrl+r-反撤销，gg=G--全文对齐

//编译器：gcc/g++
//gcc是C语言的编译器;g++是C++的编译器
/*编译过程											   -o 指定生成文件名称
预处理：将代码展开（引入头文件，宏替换，删除注释....） gcc-E filename 只进行预处理
编译：纠错，并将高级代码解释为汇编代码				   gcc-S		  只进行编译
汇编：将汇编代码解释成机器指令						   gcc-c		  只进行
链接：将所有用到的机器指令文件打包到一起，生成可执行程序,不仅仅是我们的代码文件，还包括库文件(a.c文件引用了b.h中的函数)
*/

//链接库文件的时候有两种链接方式：动态链接与静态链接
//动态链接：链接动态库，在可执行程序中记录函数符号信息表，生成可执行程序比较小，但是运行时需要加载动态库，多个程序可以使用同一库，不会在内存中造成代码冗余
//静态链接：链接静态库，直接将使用的函数写入可执行程序中，生成的可执行程序比较大，运行时不需要额外加载库，多个程序使用了相同的静态库，运行时会造成内存的代码冗余
//gcc默认链接方式：动态链接
//gcc -g a.c b.h -o main
//调试器:gdb
//加载调试：gdb ./main
//开始调试：run  直接运行 start  逐步调试
//流程控制：n  下一步(逐过程)  s  下一步(逐语句)
//			l a.c:25  查看调试行附近代码  until a.c:25  直接运行到指定行
//			c 继续运行直到断点
//断点控制：break a.c:9  给第9行打断点  watch a  给变量打断点，当变量的值发生改变时停下来  d  删除断点
//内存操作：p a 查看变量数据 backtrace查看程序运行调用栈信息，程序一旦崩溃，查看调用栈可以快速定位崩溃位置--栈顶函数

//make/Makefile
//Makefile:普通的文本文件，用于记录
//$@:表示目标对象  main
//$^:表示所有依赖对象 a.c b.c
//$<:表示所有依赖对象中的第一个依赖对象
//wildcard/patsubst 关键字的使用
//make clean 清除make生成的对象
//伪对象的使用：
//.PHONY:目标对象名称
//伪对象的作用:不管对象是否最新，每次都要重新生成
//Makefile

//git：项目版本管理工具
//1.git clone +链接  从远程仓库克隆到本地 
//2.git add ./*    添加本地文件
//3.git commit -m"删除了一个无效文件"  把文件保存到本地git
//4.git push origin master			   推送到git上