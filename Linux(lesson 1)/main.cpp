#include<iostream>
//Linux不以文件后缀区分，加后缀和颜色是为用户区分
//环境变量:就是一个变量,用于存储系统运行的环境参数
//操作指令:env set echo 查看环境变量 export 设置环境变量 unset 删除环境变量
//作用:
//1)通过修改环境变量的值,灵活的配置系统运行参数
//2)子进程会继承父进程的环境变量

///////////////////////////////////////////////////////////
//程序地址空间
//地址:内存地址---对内存以字节为存储单元的一个编号
//
/*
内核空间
环境变量,运行参数
栈(往下生长)
...
...(共享区)
堆(往上生长)
未初始化全局
初始化全局
代码段
*/
//虚拟内存地址空间:可以提高物理内存利用率,虚拟内存是连续的,但实际上在物理内存中是离散存储的
//操作系统的内存管理方式:

/*
分段式:
通过段号查到物理内存地址,再用内存地址+段内偏移量找到对应的物理内存单元
未解决内存利用率低的问题
分页式:
通过页号查到该页号的物理内存地址,再用物理内存地址+页内偏移量()找到对应的物理内存单元
优点:内存块大小跟内存页一样,物理内存块比较小,并且不要求同一进程的多个数据必须在同一个块内,因此分页式实现了数据在物理内存中的离散式存储,提高了内存利用率
页表会在进行内存访问时会进行内存访问权限查询(页表和)
12412
32位操作系统 内存4G/4k == 页表项(页号)的个数 == 2^20 
段页式:

*/
//操作系统中,虚拟内存地址和物理内存地址有一个
/////////////////////////////////////////////////////////////////////
//写时拷贝技术：子进程创建出来之后，与父进程映射访问同一物理内存，当物理内存中数据即将发生改变时(父进程数据发生改变)
//重新为子进程开辟物理内存，拷贝数据过去。好处：防止给子进程创建空间，但子进程不用，降低了进程的创建效率，造成内存冗余数据
//pid_t vfork(void)  会造成死循环(vfork创建的子进程，不能在main函数中使用return退出，因为子进程使用return退出时释放了
//所有资源,父进程运行的时候资源是错误的)


//当父进程在main函数中调用fork函数创建子进程，fork运行完毕之后，父进程应该从调用fork函数的下一步开始执行
//fork父子进程各有各的栈，vfork父子进程共用同一块栈区
//printf打印数据，实际上是把数据交给显示器，让显示器显示。先放入数据缓冲区，等积累到一定数量之后一次性输出，这样做会提高程序运行效率。
//(\n)除了换行的作用之外，还有刷新缓冲区的作用（使数据输出）
//总之vfork父子进程同一空间，fork父子进程不同空间

//进程等待：父进程等待子进程退出，为了获取退出子进程返回值，释放退出子进程的所有资源


//Linux下以.为开头的文件默认不显示(隐藏文件)


//磁盘至少有两个分区：文件交换分区，文件系统分区（且交换分区只有一个，系统分区可以有多个）
//交换分区:作为交换内存使用，通常大小在16G以内，是内存的两倍，超过时相等即可
//文件系统分区：作为文件存储使用
//程序运行，运行信息占用的是内存，内存不够用了，把非活跃区内的数据放入磁盘上（文件交换分区）这样内存就有空间加载新的数据进行处理
//windows下磁盘分了多少分区，就可以有多少盘符，每个盘符都是一个大目录（给某个空间分配文件夹）
//linux下目录结构是惟一的，不会随着分区多少而改变（给某个目录分配空间）
//挂载是指：给某个目录分配一块磁盘空间，这个目录下的文件数据存储的时候就会存储到这个空间中

//目录操作
//绝对路径：以根目录作为起始表达的路径 例：./workspace/
//相对路径：是以某个路径
// .	表示目录自身
// ..	表示目录上一层
//mkdir -p 层层递进创建目录 rmdir -p 层层删除空目录(哪层为空就删除哪一层)
//rm -rf  删除目录及目录内所有文件
//cp -r  层层拷贝目录(文件)
//mv   (剪切)移动目录的位置

//文件操作
//touch  若文件不存在则创建，若存在则刷新文件的时间属性
//cat  分页显示文件内容
//head -n 显示文件前n行
//tail -n 显示文件尾n行
//echo  打印字符串，将数据写入标准输出(显示器设备文件)"sjk666" >> filename 把sjk666写入文件
//stat  查看文件状态
//>>或者>  重定向符号，进行数据流的重定向，文件重定向(echo "1" >> file将原本要写入标准输出的数据写入文件，改变数据的流向)
//>  先清空在输入数据
//>> 直接追加数据
//|  管道符连接两个命令（head -n 23 | tail -n 1）输出第12行

//打包指令
//压缩：将一个文件按压缩算法，将数据从多变少
/*
zip
gzip
bzip2
*/
//打包：将多个文件合并成一个文件
/*
tar  Linux下使用度很高的打包解包工具
-c打包 -x解包 -z打包同时进行gzip格式的压缩解压缩 -j打包同时进行bzip2格式的压缩解压缩 -v显示打包解包信息 -f用于指定tar包的名称，通常作为最后一个选项
tar -czvf new_name file	file				打包
tar -xvf  file(不加格式，则自动检测格式)	解包(默认解压到当前目录下)
*/
//单引号（会消除字符里特殊字符的特殊含义）双引号不会
//grep  从文件里查找匹配的行(文件里找函数)
//-v  反向匹配(不包含的行) -R  对某个目录进行层层寻找(每个文件都要查找)
//find  在目录中查找指定名称/大小/时间/类型的文件
//find ./ -name"*test*" (**为模糊匹配)  
//find ./ -type d 通过文件类型查找文件 -d -
//find ./ -size -10M  通过文件大小查找10M以内文件--+10M查找超过10M大小的文件
//find ./ -mmin -10  通过文件时间查找 --cmin,mmin,amin--分钟为单位
//		  -前面都有一个减号，为**以内
//tab  快捷键，文件名自动补全
//ctrl+c --中断当前操作

//shell的理解
//操作系统内核与用户之间的桥梁---命令行解释器
//shell会捕捉用户的标准输入，得到字符串，通过字符串判断用户想要干什么
//终端能执行命令就是因为运行了一个程序--shell--命令行解释器
//Windows下的shell就是操作界面(和操作内核沟通的桥梁)
//权限：限制用户权利的东西
//文件权限对用户：所有者-u，所属组-g，其他用户-o
//文件权限对操作：可读-r，可写-w，可执行-x
//在系统中权限的存储：使用二进制
// rw-rw-r--  --> 110 110 100  占用空间小，易操作
//也可以用八进制表示用户的权限110 110 100  --> 6 6 4
