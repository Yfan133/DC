/*
task_struct结构体：
    虚拟地址空间：mm_struct

创建一个进程：
    子进程拷贝父进程的 task_struct 结构体，这个结构体中包含了虚拟地址空间mm_struct
    因此父进程和子进程的某些变量地址可能一模一样

    task_struct 结构体是双向链表，每创建一个进程内核都为其在双向链表中管理一个节点
    runqueue ：程序运行队列

fork()之后：
    1.系统分配新的内存和内核数据给子进程
    2.子进程拷贝父进程task_struct内容
    3.将子进程的task_struct结构体添加到双向链表中进行管理
    4.fork()返回，程序继续执行

注：
    1.子进程会拷贝父进程的程序计数器和上下文数据，因此子进程和父进程从同一位置开始向下执行
    2.fork()之后父子进程分两个执行流分别执行，有内核进行调度

写时拷贝技术：
    fork()后，父子进程的页表映射同一物理地址，但如果父子进程的内容即将发生改变，则操作系统为子进程重新开辟一块物理内存，并拷贝

fork()失败的可能原因：
    1.系统中有太多进程
    2.用户进程数量超过限制
*/
/*
退出一个进程：
    exit和_exit

    exit：
        1.执行用户提供的清理函数
        2.刷新缓冲区，关闭流
        3.调用_exit

    _exit：
        1.直接退出进程，并返回退出状态：只有低8位被使用(第8位core dump)，如果退出码-1，则显示255
            因此缓冲区的数据不会被输出，直接随着进程退出释放掉了

    主线程的return
        1.return 1 等同于 exit(1)，return 的返回值会当作exit的参数
*/

/*
进程等待：
    1.等待回收任意进程
        pid_t wait(int* status);    低8位表示退出状态,第8位core dump，低7位是退出码

    2.可等待回收指定进程
        pid_t waitpid(pid_t pid, int* status, int options);

    判断进程是否正常退出
    int pid = wait(&st);
    if (pid > 0 && (st & 0x7f) == 0)
        cout << 正常 << endl;
*/
/*
进程替换：
    进程程序替换之后，进程的代码段和数据段会被替换成新程序，并开始执行新的程序
*/

/*
基础IO
    每个进程在task_struct结构体中都有一个文件描述符表，他是一个数组叫fd_array[]，数组的下标就是：文件描述符，而数组元素是：文件指针，指向文件表项
        文件表项：包括文件状态标志(读、写、同步、非阻塞等)，文件偏移量和 inode 节点指针
        inode 节点：保存文件的长度，文件所有者和文件在磁盘的位置等

    多个进程打开同一个文件：共享 inode 节点(文件长度)，但是拥有自己的文件表项(偏移量)
    父子进程或者同一进程使用 dup2 重定向：可能共享一个文件表项

文件写操作：
    1.当偏移量超过文件长度，则更新inode节点的文件长度。
    2.多个进程同时对同一文件进行写操作，不保证原子性操作。

缓冲区：C库提出的，因此系统调用都不具有缓冲区，系统调用：write、read都是不带缓冲区的

fork()子进程之前，父进程进行了printf、fwrite、write但是没有刷新缓冲区，则子进程拷贝父进程缓冲区，因此子进程也输出了

创建一个文件的流程：
    1.文件属性：内核找到一个空闲的 inode 节点，并把文件信息保存在其中
    2.存储数据：在磁盘中找到几个数据块然后把数据分块存储
    3.添加文件名到目录：一个文件默认目录：。和当前文件名

硬连接：共享inode节点
软连接：不同的inode节点，软连接的inode指向的磁盘数据是另一个文件名

静态库.a：编译连接时将库代码链接到可执行文件中，文件比较大
动态库.so：运行时，由操作系统从磁盘中将该动态库中的内容复制到内存中。操作系统采用虚拟内存机制，允许物理内存中的一份动态库数据被多个进程共享

*/

/*
小端：低位放到低地址处
大端：低位放到高地址处
大小端区分：联合，char和int共用内存，char = 1则说明小端

内存对齐：
    1.先将每个数据对齐到对齐数的整数倍位置处
        对齐数 = 默认对齐数 和 数据的大小 较小值
    2.结构体的总大小 = 最大数据的大小的整数倍

内存对齐的好处：
    1.寄存器从内存中读取数据只需要一次
    2.针对可移植性，内存对齐的数据可移植性较好

文件的运行过程：
    1.预处理：去掉注释、宏替换、预处理指令
    2.编译：每个源文件分离编译，生成目标文件
    3.汇编：生成符号表
    4.链接：合并目标文件，处理未解决符号表，引入库函数

this指针：指向当前对象，在函数体中操作成员变量都是通过this指针
    特点：
        1.类成员函数的第一个隐藏的参数
        2.存储在ecx寄存器中，由ecx传递给函数
        3.通过操作偏移量，访问下一个成员变量
*/

/*
继承：
    菱形继承下的问题：
        1.数据冗余：基类的成员变量_a在子类D中有两份
            一份继承自B，一份继承自C
        2.二义性：对_a赋值，编译器不知道给谁赋值
    解决：虚拟继承-》在继承权限前加virtual
        1.将_a存放到对象模型的最下面
        2.把原来的_a改成虚基表指针，指向虚基表中不同的偏移量
        3.虚基表：偏移量1和偏移量2
        4.访问_a时只需要加上偏移量
    注：编译器会给派生类C生成一份默认构造函数，目的为了给虚基表指针赋值

多态：
    构成条件：-》被virtual修饰的基类函数
        1.继承下，对基类函数进行重写
        2.通过基类指针或者引用，调用虚函数
    重写的三种情况：
        1.派生类的重写函数原型和基类一致(返回值、函数名、参数列表)
        2.协变：基类返回基类指针，派生类返回派生类的指针
        3.析构函数：只要用virtual修饰，就构成重写，编译器同一处理：destructor
    注：基类涉及资源管理时，必须对析构进行重写。否则基类指针指向子类动态时，不会调用子类析构释放资源
    
    final：不能被继承和重写
    override：检测是否重写了某个虚函数

    抽象类概念：
        1.包含纯虚函数的类，如果子类不进行重写则子类也是抽象类
        2.抽象类不能实例化对象

    对象模型：
        1.最上面是虚表指针，指向虚表
        2.虚表是在编译阶段就被创建出来，在实例化对象时通过构造函数给虚表指针赋值，指向虚表
        3.虚表中最上面是基类虚函数地址，若进行了重写则对函数地址进行改写

    4种默认构造：
        1.类A包含类B，类B中包含无参或者全缺省构造
        2.类A继承类B，类B中包含无参或者全缺省构造
        3.类A虚拟继承自类B，给前4字节虚基表指针赋值
        4.类A中有虚函数，给前4字节虚表指针赋值


    多态体现过程：
        1.取对象地址，从前4字节取出虚表地址
        2.传递this指针
        3.通过虚表和指针偏移量找到函数入口地址
        4.调用函数，传递this实参

    小结：
        1.虚表存放在代码段(常量区)，本质函数指针数组，不能被修改
        2.静态绑定：编译期间就决定了行为，函数重载
        3.动态绑定：运行时才能体现出行为。
*/

/*
迭代器是一种设计模式，也是STL六大组件之一，方便了算法的实现，遍历时不会暴露底层实现细节
迭代器失效：
    1.迭代器的本质就是指针，或者是对指针的封装
    2.指针所指向的空间被释放，继续使用这段非法空间造成程序崩溃
解决：每次可能造成失效的地方重新赋值

vector和list区别：
    1.底层实现
    2.迭代器失效
    3.访问
    4.遍历
    5.空间利用率
*/